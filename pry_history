Cart.all
Cart.first
Cart.first.cart_items
Product.all
exit
Strength.create!(100)
Strength.new
Strength.create!(strength: 100)
ProductStrength.create!(product: Product.first, strength: Strength.first)
Product.all.each do |product|
  Strength.all.each do |strength|
    ProductStrength.create!(product: product, strength: strength)
  end
end
ProductStrength.all
rails s
exit
User.last.cart_items
User.last.cart
User.last.cart.cart_items
exit
User.first.cart_items
User.last.cart_items
exit
CartItem.last
exit
continue
browser
string
browser.link(href: /#{string}/).exists?
browser.link(href: /introduction/).exists?
browser.link(href: /dsc-1-03-01/).exists?
/#{string}/
exit
arr = [1,2,3]
arr.map(&:to_s)
arr.map(:to_i.to_proc)
arr.map(&:to_s.to_proc)
arr.map(&:to_i.to_proc)
exit
Cart.all.last.cart_items
exit
Product.all.take(3)
array = (0..5).to_a
array.take(3)
exit
Cloudinary::Cloudinary
Cloudinary
Cloudinary::Uploader
Cloudinary::Uploader.upload("placholder.jpg")
Cloudinary::Uploader.upload("./placholder.jpg")
Cloudinary::Uploader.upload("app/assets/images/placholder.jpg")
ls
exit
Cloudinary::Uploader.upload("placholder.jpg")
Cloudinary::Uploader.upload("placeholder.jpg")
exit
Cloudinary::Uploader.upload("app/assets/images/review_cartoon.png")
exit
Cloudinary::Uploader.upload("app/assets/images/cartoon.pdf")
exit
Cart.last
Cart.last.cart_items
Cart.last.cart_items.delete_at(4)
Cart.last.cart_items.delete(4)
Cart.last.cart_items.delete(3)
Cart.last.cart_items
exit
CartItem.last.quantity
Cart.last
Cart.last.cart_items
Cart.last.cart_items.delete(2)
Cart.last.cart_items.delete(5)
Cart.last.cart_items.delete(6)
Cart.last.cart_items
reload!
Cart.last.cart_items
reload!
Cart.last.cart_items
Cart.last.cart_items.delete(8)
reload!
Cart.last.cart_items.delete(8)
Cart.last.cart_items
exit
Product.all
exit
Cart.find(1).user
User.find(2).cart_items
exit
next
@amount
next
user
next
coupon
next
coupon.present?
next
@address
user.addresses
next
@address
address_params
address_params.to_a
address.first_line
@address.first_line
@address.user = user
array = [@address.first_line, @address.second_line, @address.postcode, @address.city]
user.addresses
class Address ; def get_address ;     [self.first_line, self.second_line, self.postcode, self.city]
; end ; end
@address.get_address
class Address < ApplicationRecord
  def get_address
    return     [self.first_line, self.second_line, self.postcode, self.city]
  end
end
class Address
  def get_address
    return     [self.first_line, self.second_line, self.postcode, self.city]
  end
end
@address.get_address
get_address
user.addresses.map {|i|     [self.first_line, self.second_line, self.postcode, self.city]
}
user.addresses.map {|self|     [self.first_line, self.second_line, self.postcode, self.city]}
user.addresses.map {|self|     [self.first_line, self.second_line, self.postcode, self.city] }
user.addresses.map {|s|     [s.first_line, s.second_line, s.postcode, s.city] }
user.addresses
@address.user = user
user.addresses
user
@address
@address.save!
@address.update(postcode: "n10af")
@address
user.addresses
user
@address.user
@address.save
@address.persisted?
user.persisted?
user.addresses
@address
@address.user
user.orders
user.cart
user.cart_items
user.carts
user.addresses
Address.all
Address
User.all
exit
next
up
next
up
continue
up
step
continue
a = [[1,2,3],[1,2,3]]
a.uniq
hash = {"id"=>"8ac7a4a067839980016792f49840705a", "paymentType"=>"DB", "paymentBrand"=>"VISA", "amount"=>"79.00", "currency"=>"EUR", "descriptor"=>"4257.3395.8146 OPP_Channel", "result"=>{"code"=>"000.100.110", "description"=>"Request successfully processed in 'Merchant in Integrator Test Mode'"}, "resultDetails"=>{"clearingInstituteName"=>"Elavon-euroconex_UK_Test"}, "card"=>{"bin"=>"420000", "last4Digits"=>"0000", "holder"=>"g jones", "expiryMonth"=>"10", "expiryYear"=>"2020"}, "customer"=>{"ip"=>"90.255.34.185"}, "threeDSecure"=>{"eci"=>"07"}, "customParameters"=>{"SHOPPER_EndToEndIdentity"=>"54f142e8cd9f7ea8a01d3afdb5200c20955128fde41cc024e3f0f93d5bdb17d2", "CTPE_DESCRIPTOR_TEMPLATE"=>""}, "risk"=>{"score"=>"100"}, "buildNumber"=>"7469d0e5bd2dccca50bbd107625279e76a2c9ff3@2018-12-04 10:59:49 +0000", "timestamp"=>"2018-12-09 12:32:42+0000", "ndc"=>"1E576106CC01287BFF8DDCC11FA641EA.uat01-vm-tx02"}
hash[:code]
hash[:result][:code]
hash[:result]
hash["code"]
exit
User.find(2)
User.find(2).carts
reload!
User.first
User.first.update(first_name: "Admin", last_name: "administrator")
!!!
Cart.all.where(active: false)
Cart.active
Cart.orders
Cart.where(active: true)
Cart.where(active: nil)
Cart.where(active: !nil)
!nil
Cart.where(user: nil)
Cart.where(user: !nil)
User.order("id desc")
User.guest?
User.first
User.first.guest
User.first
User.first.addresses
User.first.addresses.build(first_line: "Fourfive, city: "London", postcode: "n1 0af")
User.first.addresses.build(first_line: "Fourfive", city: "London", postcode: "n1 0af")
User.first.orders
User.first.addresses
Address.last
Address.all
eixt
exit
Address.all
Address.create(first_line: "firstline", postcode: "n1 0af", city: "london", user: 10)
User.all
Address.create(first_line: "firstline", postcode: "n1 0af", city: "london", user_id: 1)
User.first.addresses
serialize Address.first
Address.find(1)
Address.find(2)
Address.find(2).update(first_line: "24 orkney house", second_line: "199 caledonian road")
Cart.first
Cart.first.user
Cart.find
Cart.find(1)
Address.find(2)
exit
Address.first
Address.first.cart
Address.find(2)
exit
item = InvoicePrinter::Document::Item.new(
  name: 'Web consultation',
  quantity: nil,
  unit: 'hours',
  price: '$ 25',
  tax: '$ 1',
  amount: '$ 100'
)
invoice = InvoicePrinter::Document.new(
  number: '201604030001',
  provider_name: 'Business s.r.o.',
  provider_tax_id: '56565656',
  provider_tax_id2: '465454',
  provider_street: 'Rolnicka',
  provider_street_number: '1',
  provider_postcode: '747 05',
  provider_city: 'Opava',
  provider_city_part: 'Katerinky',
  provider_extra_address_line: 'Czech Republic',
  purchaser_name: 'Adam',
  purchaser_tax_id: '',
  purchaser_tax_id2: '',
  purchaser_street: 'Ostravska',
  purchaser_street_number: '1',
  purchaser_postcode: '747 70',
  purchaser_city: 'Opava',
  purchaser_city_part: '',
  purchaser_extra_address_line: '',
  issue_date: '19/03/3939',
  due_date: '19/03/3939',
  subtotal: '175',
  tax: '5',
  tax2: '10',
  tax3: '20',
  total: '$ 200',
  bank_account_number: '156546546465',
  account_iban: 'IBAN464545645',
  account_swift: 'SWIFT5456',
  items: [item],
  note: 'A note...'
)
invoice.render
item.render
InvoicePrinter.render(
  document: invoice
)
f = File.new("pdf.pdf", 'w')
f << InvoicePrinter.render(document:invoice)
invoic
invoice
InvoicePrinter.print(
  document: invoice,
  labels: labels,
  page_size: :a4,
  file_name: 'invoice.pdf'
)
exit
item = InvoicePrinter::Document::Item.new(
  name: 'Web consultation',
  quantity: nil,
  unit: 'hours',
  price: '$ 25',
  tax: '$ 1',
  amount: '$ 100'
)
invoice = InvoicePrinter::Document.new(
  number: '201604030001',
  provider_name: 'Business s.r.o.',
  provider_tax_id: '56565656',
  provider_tax_id2: '465454',
  provider_street: 'Rolnicka',
  provider_street_number: '1',
  provider_postcode: '747 05',
  provider_city: 'Opava',
  provider_city_part: 'Katerinky',
  provider_extra_address_line: 'Czech Republic',
  purchaser_name: 'Adam',
  purchaser_tax_id: '',
  purchaser_tax_id2: '',
  purchaser_street: 'Ostravska',
  purchaser_street_number: '1',
  purchaser_postcode: '747 70',
  purchaser_city: 'Opava',
  purchaser_city_part: '',
  purchaser_extra_address_line: '',
  issue_date: '19/03/3939',
  due_date: '19/03/3939',
  subtotal: '175',
  tax: '5',
  tax2: '10',
  tax3: '20',
  total: '$ 200',
  bank_account_number: '156546546465',
  account_iban: 'IBAN464545645',
  account_swift: 'SWIFT5456',
  items: [item],
  note: 'A note...'
)
rendered_pdf = InvoicePrinter.redner(document: invoice)
rendered_pdf = InvoicePrinter.render(document: invoice)
PDF::Inspector::Text.analyze(rendered_pdf).strings
PDF
PDF::Inspector::Text
PDF::Inspector
PDF.constants
PDF::Core
PDF::Core.constanst
PDF::Core.constants
PDF::Core::Text.analyz
PDF::Core::Text.analyze
PDF::Core::Text.methods
PDF::Core::Text.methods(false)
PDF::Core::Text.instance_methods
rendered_pdf = InvoicePrinter.print(document: invoice)
rendered_pdf = InvoicePrinter.print(document: invoice, file_name: invoice.pdf)
rendered_pdf = InvoicePrinter.print(document: invoice, file_name: "invoice.pdf")
a = b = true
a
[1,2,3]
[1,2,3].methods
[1,2,3].methods.grep /each/
[1,2,3].each
Enumerable
Enumerable.methods
Enumerable.methods.grep /each/
exit
class Dog
  def initialize(attr)
    @name = attr[:name]
  end
end
Dog.new(name: "name")
exit
Cart.first
Address.all
Address.create(cart_id: 1, first_line: "Hillfoot", city: "London", postcode: "n1 0af", first_name: "guy", last_name: "jones")
Cart.first
Cart.first.cart_items
CartItem.create(cart_id: 1, product_id: 2, quantity: 5)
Cart.first.cart_items
Cart.first.amount
Product.first
exit
[nil, "allen"]
[nil, "allen"].compact
[nil, "allen"].compact.join(" ")
[nil, "allen"].compact.join
['asdf', "allen"].compact.join
exit
Coupon
exit
Cart.all
Cart.find(1)
Cart.find(1).address
exit
Cart.new
exit
Cart.new
exit
Cart.new
exit
Cart.last
Cart.last.address
Cart.last.address = nil
exit
Cart.all
carts = Cart.all.where(active: true).where("updated_at < ?", 1.weeks.ago)
carts = Cart.all.where(active: true).where("updated_at < ?", 0.weeks.ago)
Cart.create(user_id: 1)
Cart.all.delete_all
reload!
Cart.all.delete_all
exit
Cart.all.delete_all
exit
Cart.all.delete_all
Cart.all
CartItem.first
CartItem.find(1)
CartItem.find(1).delete
CartItem.all
CartItem.create(cart_id: 1, product_id: 1)
Cart.find(1)
Cart.find(1).delete
exit
Cart.all.delete_all
Cart.all.destory
Cart.all.destroy_all
Cart.all
Cart.create(user_id: 1)
Cart.all.delete_all
CartItem.all
exit
Cart.create(user_id: 1)
reload!
Cart.all
CartItem.create(cart_id: 1, product_id: 1)
CartItem.create!(cart_id: 1, product_id: 1)
Product.create(name: "asdf")
CartItem.create!(cart_id: 1, product_id: 1)
Cart.all.delete_all
exit
Cart.all
CartItem.create(cart_id: 1, product_id:1)
Cart.all.delete_all
reload!
Cart.all.delete_all
Cart.all.destroy_all
Cart.all
CartItem.all
exit
30.days.ago
Time.now - 30.days
reload!
Cart.all
Cart.all.recent
reload!
Cart.all.recent
reload!
Cart.all.recent
Cart.all.old
reload!
Cart.all.old
1.days.ago
1.day.ago
exit
Cart.all
exit
Cart.all
User.all
exit
User.find(2)
User.find(2).cart
User.find(2).cart.amount
exit
Product.find(1)
Product.find(3)
Product.find(2)
Product.create!(name: 'cbd balms', price: 29.99, subtitle: "Organic balms for damaged skin", description: "Because your skin it the largest working organ, we’ve created a soothing, safe and protective application for it. Made with organic ingredients, our hand-blended and hard-working balm is kind to all skin types.", photo: open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1543755363/pqje5y6qblpza9f4cxdn.jpg"))
%w(asdf asdf)
%w(asdf asdf&s)
%w(asdf asdf& s)
["Aches", "Sprains", "Tendon inflammation", "Muscle inflammation", "Localised pain (including knees, hands, shoulders & elbows)", "Psoriasis ", "Acne", "Eczema", "Grazes", "Minor burns"]
exir
Product.find(1).help
oil_help = ["Stress relief", "Anti-inflammatory", "Sleep patterns", "Relieving of anxiety", "Easing mild depression", "Calming nerves"]
Product.find(1).update(help: oil_help)
Product.find(1).help
exit
exit
Product.first
Product.find(2).how_to_user
Product.find(2).how_to_use
Product.find(2).how_to_use.split(\n)
Product.find(2).how_to_use.split("\n")
Product.find(2)
exit
%w(natural orange)
%w(small large 500mg 1000mg 2000mg)
p = Product.create!(name: 'cbd oils', size: "500mg", tincture: "natural", price: 29.99, help: oil_help, how_to_use: oil_how_to, ingredients: oil_ingr, subtitle: "Flavored oils for quick absorption", description: "Quick-absorbing and easy-to-use cbd oils. Made with 100% natural and organic ingredients. Our process of CO2 extraction means the highest available nutritional value is packed in to every drop of fourfive cbd oil. Each of our bottles contain roughly 120 drops.", photo: open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1543755363/pqje5y6qblpza9f4cxdn.jpg"))
balm_help = ["Aches", "Sprains", "Tendon inflammation", "Muscle inflammation", "Localised pain (including knees, hands, shoulders & elbows)", "Psoriasis ", "Acne", "Eczema", "Grazes", "Minor burns"]
balm_how_to = "Swallow with food. We recommend starting by taking one capsule once or twice a day. you can then increase your dose over time. Generally, we have seen customers take an average of two to four capsules of cbd per day. Please do not go over the 200mg food supplement daily limit (forty capsules)"
balm_ingr = ["Vegetable capsule", "Hemp extract", "Coconut oil", "Not recommended if you suffer from nut allergies"]
oil_help = ["Stress relief", "Anti-inflammatory", "Sleep patterns", "Relieving of anxiety", "Easing mild depression", "Calming nerves"]
oil_how_to = "Apply on to the targeted area of your skin and rub until fully absorbed. For external use only."
oil_ingr = ["Hemp extract", "Coconut oil", "Not recommended if you suffer from nut allergies"]
capsule_help = ["Arthritis", "Muscle stiffness", "Management of Fibromyalgia", "Inflammatory disorders"]
capsule_how_to = "We recommend starting with 3 drops of the lower strength oil twice a day. To take simply drop the cdb oil under your tongue using the pipette or the spray. This achieves the best possible absorption rates and bioavailability. \n You can then increase the dosage as required on a weekly basis, to a maximum of 6 drops twice a day, until the desired results are achieved. \n If you find that you’re nearing the end of the bottle and you’re already taking 6 drops twice a day but it isn’t hitting the spot, we would recommend upgrading to our regular or higher strength cbd oil."
capsule_ingr = ["Coconut oil", "Hemp extract", "Vegetable capsule"]
capsule_desc = "Our cbd capsules contain full-spectrum, co2 extracted hemp infused in coconut oil and capped in vegan capsules. They are easy-to-use and slow-to-release, great for when you only need a small amount of cbd product over a longer period of time."
p = Product.create!(name: 'cbd oils', size: "500mg", tincture: "natural", price: 29.99, help: oil_help, how_to_use: oil_how_to, ingredients: oil_ingr, subtitle: "Flavored oils for quick absorption", description: "Quick-absorbing and easy-to-use cbd oils. Made with 100% natural and organic ingredients. Our process of CO2 extraction means the highest available nutritional value is packed in to every drop of fourfive cbd oil. Each of our bottles contain roughly 120 drops.", photo: open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1543755363/pqje5y6qblpza9f4cxdn.jpg"))
Product.create!(name: 'cbd capsules', price: 3, help: balm_help, how_to_use: capsule_how_to, ingredients: capsule_ingr, subtitle: "Easy-to-take capsules for slower release", description: capsule_desc, photo: open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1543755363/pqje5y6qblpza9f4cxdn.jpg"))
reload!
Product.create!(name: 'cbd capsules', price: 3, help: balm_help, how_to_use: capsule_how_to, ingredients: capsule_ingr, subtitle: "Easy-to-take capsules for slower release", description: capsule_desc, photo: open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1543755363/pqje5y6qblpza9f4cxdn.jpg"))
exit
e
exit
['net/https', 'uri', 'json'].each(&method(:require))
JSON
exit
JSON
URI
require 'json'
['net/https', 'uri', 'json'].each(&method(:require))
require 'json'
['net/https', 'uri', 'json'].each(&(:require))
['net/https', 'uri', 'json'].each(&:require)
exit
%w[ 500mg 1000mg 2000mg]
exit
Address.find(1)
Address.all
Cart.fin
Cart.all
Cart.find(1).amount
reload!
Cart.find(1).amount
exit
Cart.find(1).amount
Cart.find(1).quanitty
Cart.find(1).quantity
exit
Cloudinary::Uploader.upload
Cloudinary::Uploader.upload("capsules.jpg")
Cloudinary::Uploader.upload("capsule.jpg")
exit
Cloudinary::Uploader.upload("capsule.jpg")
Cloudinary::Uploader.upload("balm_300.jpg")
Cloudinary::Uploader.upload("balm_300.jpeg")
exit
puts DIR.pwd
puts dir.pwd
puts Dir.pwd
Cloudinary::Uploader.upload("app/assets/images/products/balm_300.jpeg")
Cloudinary::Uploader.upload("app/assets/images/products/balm_300.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/balm_800.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/capsule.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/natural_lower.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/natural_medium.jpg")
exit
Cloudinary::Uploader.upload("app/assets/images/products/natural_medium.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/natural_higher.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/orange_higher.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/orange_medium.jpg")
Cloudinary::Uploader.upload("app/assets/images/products/orange_lower.jpg")
exit
Product.find(2).description
Product.find(2).update(               description: "Because your skin it the largest working organ, we’ve created a soothing, safe and protective application for it. Made with organic ingredients, our hand-blended and hard-working balm is kind to all skin types.",
)
Product.find(2).description
exit
Product.find(1).description
Product.find(2).description
Product.find(3).description
exit
Cloudinary::Uploader.upload("app/assets/images/Testimonials_and_images/chris circle")
exit
Cloudinary::Uploader.upload("app/assets/images/Testimonials_and_images/chris.jpg")
Cloudinary::Uploader.upload("app/assets/images/Testimonials_and_images/nathan.jpg")
Cloudinary::Uploader.upload("app/assets/images/Testimonials_and_images/nadia.jpg")
exit
Product.all
Product.first.name
Product.first.name.gsub("_", " ")
Product.first.tincture
Product.find(6).tincture
Product.find(6).size
exit
ProductGroup.first
Product.find(1)
Product.create(name: "asdf")
Product.create(name: "asdf").valid?
Product.new(name: "asdf").errors
Product.new(name: "asdf").valid?.errors
Product.new(name: "asdf").valid?
p =Product.new(name: "asdf").valid?
p.errors
p =Product.new(name: "asdf")
p.valid?
p.errors
p =Product.new(name: "asdf",product_group_id: 1)
exit
Product.find(1).product_group
ProductGroup.first.products
reload!
ProductGroup.first.products
exit
Cloudinary::Uploader.upload("app/assets/images/products_new/cbdoilnaturallower.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilnaturallower.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilnaturalmedium.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilnaturalhigher.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilorangehigher.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilorangemedium.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/cdboilorangelower.jpg")
exit
Cloudinary::Uploader.upload("app/assets/images/products_new/oil_inter.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/balm_inter.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/capsules_inter.jpg")
exit
Cloudinary::Uploader.upload("app/assets/images/products_new/capsules.jpg")
ProductGroup.find(1)
ProductGroup.find(1).photo = open("https://res.cloudinary.com/dq2kcu9ey/image/upload/v1545310996/g9l7hk0dbiii7fkjcq9r.jpg")
ProductGroup.find(1).update(photo: open("https://res.cloudinary.com/dq2kcu9ey/image/upload/v1545310996/g9l7hk0dbiii7fkjcq9r.jpg"))
exit
Product.find(4)
exit
next
"#{ENV['ZION_USER_ID']}"
"#{@amount}"
next
@result["id"]
@result
continue
up
next
exit
continue
@amount.to_f
#{ENV['ZION_USER_ID']}
"#{ENV['ZION_USER_ID']}"
"#{ENV['ZION_ENTITY_ID']}"
"#{ENV['ZION_TEST_PWD']}"
continue
up
"#{ENV['ZION_USER_ID']}"
req
req.data
req.get_form_data
req.form_data
req
req.method
req.methods
req.bod
req.body
req.header
req.head
req.methods
req.to_hash
req.body
next
continue
up
req
req.to_hash
req.methods
req.body_stream
req.stringify_keys
req.parse_header
req.type_params
req.get_fields
req.each_value {|i| puts i}
whereami
req.each_header {|i| puts i}
req.header
req.amount
req.params
req.uri
req.body
exit
change = {"500mg": "Lower", "1000mg": "Medium", "2000mg": "Higher"}
size = "500mg"
change[size]
change[size.to_sym]
exit
ProductGroup.find(2)
ProductGroup.find(3)
ProductGroup.find(3).update(description: "Quick-absorbing cbd oils made with 100% natural ingredients and designed to help you support and maintain an active lifestyle. Our process of CO2 extraction means the highest available nutritional value is packed in to every drop of fourfive cbd oil. Each 30ml bottle contains around 120 drops and is supplied with a pipette and a handy spray applicator.")
ProductGroup.find(2)
ProductGroup.find(1)
ProductGroup.find()
exit
Cloudinary::Uploader.upload("app/assets/images/products_new/smallbalm.jpg")
Cloudinary::Uploader.upload("app/assets/images/products_new/largebalm.jpg")
Product.find(1)
Product.find(2)
Product.find(2).update(photo: open("https://res.cloudinary.com/dq2kcu9ey/image/upload/v1545330419/zdilgiei86tpd8u0wkbc.jpg"))
Product.find(3)
Product.find(3).update(photo: open("https://res.cloudinary.com/dq2kcu9ey/image/upload/v1545330449/go6ereapuoyjqepenvk6.jpg")
)
exit
exit
Cart.all
Cart.all.amount
Cart.find(2).amount
Cart.find(2).cart_items
Product.find(4)
Cart.all
Cart.find(2)
Cart.find(2).cart_items
Date.today
Date.today.to_s
"#{Date.today}"
"#{Date.today.strftime(%A)}"
"#{Date.today.strftime('%A, %b %d')}"
Date.today.strftime('%A, %b %d')
!!!
Cart.updated_at
Cart.find(1)updated_at
Cart.find(1).updated_at
Cart.find(1).updated_at.strftim('%A')
Cart.find(1).updated_at.strftime('%A')
exit
Cart.all.last
Cart.all.last.basket
Cart.all.cart_items
Cart.last.cart_items
Cart.last.cart_items.delete(6)
Cart.last.cart_items.destroy(6)
Cart.last.cart_items
reload
reload!
Cart.last.cart_items
Cart.last.cart_items.map {|i| i.specific_name}
Cart.last.cart_items.map {|i| i.product.specific_name}
exit
Cart.all.last.count
Cart.all.last
Cart.all.last.cart_items
Cart.all.last.cart_items.collect(&:quantity)
Cart.all.last.cart_items.collect(&:quantity).reduce(:+)
Cart.all.last.cart_items.reduce{|i| i.quantity}
Cart.all.last.cart_items.reduce{|c,i| c += i.quantity}
Cart.all.last.cart_items.reduce(0){|c,i| c += i.quantity}
Cart.all.last.cart_items.sum {|i| i.quantity}
Cart.all.last.cart_items.sum(&:quantity)
exit
CartItem.all
-1.negative?
-1.postive?
-1.positive?
clear
ls
exit
Cart.find(5).cart_items
selections = "tinctures"
selections
selections.inspect
selections.to_s
@names = ProductGroup.collect(&:name)
@names = ProductGroup
@names = ProductGroup.all.collect(&:name)
@names = 
@names
@names.inspect
@names.to_s
@names.variable_name
@names.constantise
@names.methods
@names.pretty_inspect
@names.instance_variables
@names.instance_variable_names
@names.instance_variable_name
@names.instance_variable_get
@names.full_name
@names.self
@names.itself
@names.class
@names.class.inspect
@names.object_id
@names.object_id.eval
eval(@names.object_id)
@names.object_id.to_s
eval(@names.object_id.to_s)
@name.binding
@names.binding
@names.to_Sym
@names.to_sym
self
self.instance_variables
whereami
selection
selections
@tinctures
selection.to_s
continue
reload!
Product.first.how_to_use_text
Product.first.how_to_use
Product.first.product_group.how_to_use
Product.last.product_group.how_to_use
Product.last.how_to_use_text
Product.last.how_to_use_text.each
reload!
Product.last.product_group
Product.last.product_group.how_to_use_text
Product.last.how_to_use_text
Product.last.how_to_use_text {|i| puts i }
exit
[1234]
[][]
[][1234]
exit
ApplicationController
ApplicationController.flashme
ApplicationController.new.flashme
ApplicationController.create
ApplicationController.new
a= aApplicationController.new
a= ApplicationController.new
a.flashme
Flash
a.flashme
exit
a = SQL<<"asdf
asdf"
a = EOF<<"asdf
asdf"
a = EOF<<"asdf
asdf" EOF
ecti
exit
@product = Product.find(5)
params = {cart_id: 1, quantity: 2}
CartItem.new(params)
a = CartItem.new(params)
ci = CartItem.new(params)
ci.product = @product
ci
ci.build
CartItem.product.build
CartItem.build_product
CartItem.methods
CartItem.methods.grep /build/
CartItem.attributes_builder
ri attributes_builder
ri :attributes_builder
CartItem.predicate_builder
CartItem.new(params)
CartItem.new(params).build_product(product_id: 1_
CartItem.new(params).build_product(product_id: 1)
@product
CartItem.new(params).product = product
CartItem.new(params).product = @product
CartItem.create(params).product = @product
@ci = CartItem.create(params).product = @product
@ci
CartItem.create(params).product = @product
CartItem.create(params)
ci = CartItem.create(params)
ci
ci.update(product: @product)
CartItem.new(cart_id:1, quantity:1)
CartItem.new(cart_id:1, quantity:1).send(:product_id, 2)
CartItem.new(cart_id:1, quantity:1).send(:product_id)
ci = CartItem.new(cart_id:1, quantity:1)
ci.send :product
@product = Product.find(1)
ci.send :product, @product
ci.respond_to? :product
ci.send :product=, @product
params
cart_params = {cart_id: 1, quantity: 2}
@cart_item = CartItem.new(cart_params).send(:product=, @product)
exit
exit
next
@producr
@product
params
Product.find_by(size: params[:size])
@product = Product.find_by(size: params[:size])
whereami
@cart
next
cart_item
next
@cart_item
@cart_item.valid?
next
continue
c
exit
Cart.all
Cart.delete(6)
Cart.destroy(6)
User.find(5)
User.find(5).cart
node
Cart.all.destroy(6)
Cart.all
Cart.all.destroy(8)
Cart.all.destroy(7)
exit
Cloudinary::Uploader.upload("app/assets/images/george.jpg")
Cloudinary::Uploader.upload("app/assets/images/dom.jpg")
Cloudinary::Uploader.upload("app/assets/images/dom.jpg", public_id: "dom")
Cloudinary::Uploader.upload("app/assets/images/george.jpg", public_id: "george_kruis")
exit
Product.all
exit
Cart.last.destroy
reload!
Cart.first
Cart.first.cart_items
CartItem.find(4)
CartItem.find(4).update(quantity: 0)
reload!
CartItem.find(4).update(quantity: 0)
CartItem.find(1).update(quantity: 0)
reload!
Cart.find(2)
CartItem.find(2).update(quantity: 0)
CartItem.find(2).update(quantity: 0).valid?
CartItem.find(2).update(quantity: 0)
reload!
CartItem.find(2)
CartItem.find(2).update(quantity: 0)
CartItem.create(cart_id: 2, product_id: 5, quantity: 1)
CartItem.last
CartItem.find(32)
CartItem.find(32).update(quantity: 0)
CartItem.find(32).quantity = 0
CartItem.find(32)
a = CartItem.find(32).quantity = 0
a
a = CartItem.find(32).quantity = 0
CartItem.find(32).assign_attributes(quantity: 0)
CartItem.find(32).assign_attributes(quantity: 0).valid?
a =CartItem.find(32).assign_attributes(quantity: 0)
a
ci = CartItem.find(32)
ci
ci.attributes
ci.assign_attributes(quantity: 2)
ci
ci.assign_attributes(quantity: 0)
ci
ci.valid?
reload!
ci.valid?
ci
ci.errors
exit
CartItem.last
CartItem.find(22)
CartItem.find(22).update(quantity: 0)
CartItem.find(22).destroy
CartItem.find(22)
exit
CartItem.last
CartItem.find(21)
CartItem.find(21).destroy
CartItem.find(20)
CartItem.find(19)
CartItem.find(19).update(quantity: 0)
CartItem.find(19).update(quantity: 0).errors
CartItem.find(19).assign_attributes(quantity: 0)
ci = CartItem.find(19)
ci
ciassign_attributes(quantity: 0)
ci.assign_attributes(quantity: 0)
ci
ci.valid?
ci
ci.valid?
ci.errors
ci.messages
CartItem._validate_callbacks
CartItem._validate_callbacks.select{|i| i.kind.eql?(:before)}
reload!
ci = CartItem.find(19)
CartItem.find(19)
CartItem.find(18)
CartItem.last
CartItem.find(16)
ci = CartItem.find(16)
ci
ci.update(quantity: 0)
ci
reload!
ci.update(quantity: 0)
ci
exit
ci = CartItem.find(16)
ci.update(quantity: 0)
ci
ci.destroy
ci
Cart.all
CartItem.all
CartItem.find(5).destory
CartItem.find(5).destroy
CartItem.all
CartItem.find(3).update(quantity: 0)
CartItem.all
exit
Cart.find(12).destroy
Cart.find(13).destroy
exit
Cart.find(14).destroy
exit
@ip
step
next
req
req.methods(false)
req.methods
req.get_fields
req.methods
req.methods.grep /form/
req.methods.grep /data/
req.methods.grep /fields/
req.get_fields
req.methods.grep /all/
req.to_json
req.params
req.body
req.body.tr('&', \n)
req.body.tr('&', "\n")
req.body.tr('&', /\n/)
req.body.tr('&', "\n").inspect
req.body.tr('&', "\n")
req.body.tr('&', "\n").to_s
puts req.body.tr('&', "\n")
@cart
@cart.user
params
params[:email]
params["email"]
params["checkout"]["email"]
@cart.address.first_name
@cart.address.first_name.to_s
@cart.address.first_line
continue
Product.find(1).name
Cart.last
Cart.where(active: true).last
Cart.where(active: false).last
Cart.find(25)
Cart.find(25).address
Cart.find(25).address.email
exit
PaymentMailer
Cart.last
Cart.find(27)
@cart = Cart.find(27)
PaymentMailer.success(@cart.address.email).deliver_now
PaymentMailer.order(email_hash).deliver_now
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
PaymentMailer.order(email_hash).deliver_now
PaymentMailer.order(email_hash)
PaymentMailer.order(email_hash).deliver_now
reload!
PaymentMailer.order(email_hash)
PaymentMailer.order(email_hash).deliver_now
PaymentMailer.order(email_hash)
wherami
whereami
self
email_hash
@address
attributes
continue
next
exit
PaymentMailer.order(email_hash)
@cart = Cart.find(27)
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
PaymentMailer.order(email_hash)
PaymentMailer.order(email_hash).deliver_now
exit
Product.all
exit
Cart.all.last
User.last
User.last.cart
Cart.lsat
Cart.last
exit
Rails.env.development?
exit
rs
exit
Address.last
Address.last.full_name
reload!
Address.last.full_name_with
Address.last.full_name
Address.last.full_name_with_salutation
exit
Address.last.update(salutation: nil)
Address.last.full_name_with_salutation
[["Natural 1000mg oil", 1], ["Small balm", 1], ["Capsules", 1], ["Natural 500mg oil", 1], ["Capsules", 1], ["Natural 500mg oil", 1], ["Natural 500mg oil", 1], ["Capsules", 2], ["Natural 500mg oil", 1], ["Capsules", 1], ["Orange 500mg oil", 1]]
arr = [["Natural 1000mg oil", 1], ["Small balm", 1], ["Capsules", 1], ["Natural 500mg oil", 1], ["Capsules", 1], ["Natural 500mg oil", 1], ["Natural 500mg oil", 1], ["Capsules", 2], ["Natural 500mg oil", 1], ["Capsules", 1], ["Orange 500mg oil", 1]]
arr.reduce{|x,y| x[1] + y[1] if x[0] == y[0]}}
arr.reduce{|x,y| x[1] + y[1] if x[0] == y[0]}
arr.first.reduce{|x,y| x[1] + y[1] if x[0] == y[0]}
arr.first
arr.reduce{|x,y| x[1] + y[1] if x[0] == y[0]}
exit
exit]
rs
exit
User.find(1)
User.find(1).update(password: "f0urf!vecbd")
exit
["Heatley", "Nichols", "Williams", "Mapp", "Fine", "Robertson", "Brockwell", "Lansley ", "Holman", "Clark", "De Bruin", "Davies", "Cole", "Hart", "White", "Fradgley", "Brown", "may", "Garrett", "Tabberer", "Mansfield", "Gidman", "Winterbottom", "Fry", "Hargrave", "Hargrave", "Kilmister", "Rowe", "Hall", "Grant", "Paling", "Springham", "Grinnell", "Scott", "Greaney", "Wozniak", "CRICHTON-COOTE", "Harris", "Cooke", "Stewart", "Ridgeon", "Wakeham", "Redfern ", "Smith", "Duncombe", "Lougher ", "Chalmers", "griffin", "Hargrave", "Clarke", "Gidman", "Henson", "Denyer ", "Marfleet", "Considine", "Drummond", "McCoy", "Dreelan", "Bloor", "Phillips", "Peach", "Andrews", "Jones", "Mead", "Woodfine", "Ellison ", "Nicholas", "Hallatt", "Pottage", "Robertson", "Dunphy", "Mccoy", "Burton", "Ackroyd", "Radford ", "Nolan", "Jones ", "Purssey", "de Boltz", "Wood", "Miller", "Ashe", "Hearsum", "Stewart", "Hulme", "White", "Freebury", "Langley", "Gregory", "Waite", "Price", "Barlow", "Smith", "Roberts"]
a = ["Heatley", "Nichols", "Williams", "Mapp", "Fine", "Robertson", "Brockwell", "Lansley ", "Holman", "Clark", "De Bruin", "Davies", "Cole", "Hart", "White", "Fradgley", "Brown", "may", "Garrett", "Tabberer", "Mansfield", "Gidman", "Winterbottom", "Fry", "Hargrave", "Hargrave", "Kilmister", "Rowe", "Hall", "Grant", "Paling", "Springham", "Grinnell", "Scott", "Greaney", "Wozniak", "CRICHTON-COOTE", "Harris", "Cooke", "Stewart", "Ridgeon", "Wakeham", "Redfern ", "Smith", "Duncombe", "Lougher ", "Chalmers", "griffin", "Hargrave", "Clarke", "Gidman", "Henson", "Denyer ", "Marfleet", "Considine", "Drummond", "McCoy", "Dreelan", "Bloor", "Phillips", "Peach", "Andrews", "Jones", "Mead", "Woodfine", "Ellison ", "Nicholas", "Hallatt", "Pottage", "Robertson", "Dunphy", "Mccoy", "Burton", "Ackroyd", "Radford ", "Nolan", "Jones ", "Purssey", "de Boltz", "Wood", "Miller", "Ashe", "Hearsum", "Stewart", "Hulme", "White", "Freebury", "Langley", "Gregory", "Waite", "Price", "Barlow", "Smith", "Roberts"]
a.cunt
a.count
a.count - 18
a.count
exit
Cart.where(active:false, fulfillment: true).first
Cart.where(active:false, fulfillment: true).udpate(fulfillment: false)
Cart.where(active:false, fulfillment: true).update(fulfillment: false)
exit
User.last
User.last.destroy
rand(100)
rand(100000)
exit
Cart.last
Address.first
Address.first.
exit
Invoice.all
exit
Cart.first
exit
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
@cart = Cart.first
@cart = Cart.orders.first
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
@cart.checkout_tim
@cart.checkout_time
@cart.update(checked_out_at: Time.now)
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
amount: email_hash[:amount],
address: email_hash[:address],
cart_items: email_hash[:cart_items],
date: email_hash[:date],
order_id: email_hash[:order_id]
amount: email_hash[:amount], address: email_hash[:address], cart_items: email_hash[:cart_items], date: email_hash[:date], order_id: email_hash[:order_id]
{amount: email_hash[:amount], address: email_hash[:address], cart_items: email_hash[:cart_items], date: email_hash[:date], order_id: email_hash[:order_id]}
a = {amount: email_hash[:amount], address: email_hash[:address], cart_items: email_hash[:cart_items], date: email_hash[:date], order_id: email_hash[:order_id]}
a.eql?(email_hash_
a.eql?(email_hash)
rs
exit
Cart.Last
Cart.last
Cart.find(36)
exit
image_tag "george.jpg", height: 500
Cloudinary::Utils.cloudinary_url("george.jpg")
Cloudinary::Utils.cloudinary_url("george.jpg", height: 500)
Cloudinary::Utils.cloudinary_url("george.jpg", :width => 50, :height => 50,)
Cloudinary::Utils.cloudinary_url("george.jpg", :width => 50, :height => 50, crop: :scale)
exit
ProductGroup.first
ProductGroup.first.photo
ProductGroup.first.photo_url
ProductGroup.first.photo
exit
Cart.includes(:address)
Cart.includes(:address, :carts).count
Cart.includes(:address).count
Cart.includes(:address, :cart_items).count
Cart.includes(:address, :cart_items)
Cart.includes(cart_items: :product).orders.map(&:amount).compact.reduce(:+)
reload!
Cart.includes(cart_items: :product).orders.map(&:amount).compact.reduce(:+)
exit
Cart.count
User.count
exit
@cart = Cart.last(20)
@cart = Cart.where(active: true).last(10)
@cart = Cart.where(active: true).where(product: true)
@cart = Cart.where(active: true)
@cart = Cart.where(active: true).pluck(:id)
Cart.find(3).products
Cart.find(3).cart_items
Cart.find(11,12).cart_items
Cart.find(11).cart_items
Cart.find(12).cart_items
Cart.find(13).cart_items
Cart.find(14).cart_items
Cart.find(144)
Cart.find(144).cart_items
@cart = Cart.find(150)
@cart.cart_items
@cart = Cart.find(434)
@cart.cart_items.includes(product: :product_group).sort_by{ |i| i.product.name }
@cart.cart_items
@cart.cart_items.includes(product: :product_group)
exit
Cart.orders.first
Cart.orders.first.email
Cart.orders.first.address.email
Cart.orders.first.address
Cart.orders.first.address.first_name
Cart.orders.first.address.email
class Coupon; coupon = ["a","b"]; end
Coupon
Coupon.coupon
class Coupon
  def self.coupon
    ['a','b']
  end
end
Coupon.coupon
reload!
exit
Coupon.coupon
Coupon
EmailInterceptor
require 'coupon'
Coupon
Coupon.coupon
exit
DeleteOldUsers
DeleteOldUser
DeleteOldUsersJob
DeleteOldUsersJob.perform_now
DeleteOldUsersJob.perform_later
FakeJob
reload!
DeletecartJob
DeletecartJob.perform_now
DeletecartJob.perform_later
DeleteOldUsersJob.perform_later
DeleteOldUsersJob.perform_now
reload!
DeleteOldUsersJob.perform_now
reload!
DeleteOldUsersJob.perform_now
DeleteOldUsersJob.perform_later(true)
DeleteOldUsersJob.perform_now
Address.where(first_name: "guy")
Cart.find(857)
@cart = Cart.find(857)
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
pdf = InvoicePdf.new(email_hash)
PaymentMailer.success(@cart.address.email, pdf).deliver_now
PaymentMailer.success(@cart.address.email, pdf).deliver_later
reload!
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
PaymentMailer.success(@cart.address.email, email_hash).deliver_later
reload!
@cart
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
PaymentMailer.success_later(@cart.address.email, @cart.id).deliver_later
reload!
PaymentMailer.success_later(@cart.address.email, @cart.id).deliver_later
reload!
PaymentMailer.success_later(@cart.address.email, @cart.id).deliver_later
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
reload!
DeleteOldUsersJob
DeleteOldUsersJob.perform_now
DeleteOldUsersJob.perform_now(false, 4)
exit
Cart.where(address: {email: !nil})
Cart.where(address: {email: !nil}).count
Cart.joins(:addresses).where(address: {email: !nil}).count
Cart.joins(:addresses).where(addresses: {email: !nil}).count
Cart.joins(:address).where(addresses: {email: !nil}).count
Cart.joins(:address).where(address: {email: !nil}).count
Cart.joins(:address).merge(Address.where(email: true))
Cart.joins(:address).merge(Address.where(email: !nil))
Cart.joins(:address).merge(Address.where.not(email: nil))
Cart.joins(:address).merge(Address.where.not(email: nil)).count
Cart.orders.count
Cart.joins(:address).count
Cart.count
Cart.includes(:address).where.not(address: {id: nil})
Cart.includes(:address).where.not(address: {id: nil}).count
Cart.joins(:address).count
Cart.joins(:address).merge(Address.where.not(id: nil)).count
Cart.joins(:address).merge(Address.where.not(email: nil)).count
Address.where(email: nil).first(2)
Cart.joins(:address).merge(Address.where.not(email: nil)).count
Cart.joins(:address).count
Cart.orders
Cart.orders.count
Cart.joins(:address).count
Cart.joins(:address).merge(Address.where.not(email: nil))
Cart.joins(:address).merge(Address.where.not(email: nil)).count
Cart.joins(:address).count
Cart.orders.count
Cart.!orders.count
Cart.not.orders.count
Cart.all - Cart.orders
not_orders = (Cart.all - Cart.orders)
Cart.joins(:address).merge(Address.where.not(email: nil)).count
Cart.joins(:address).count
Cart.orders.count
not_orders.joins(:address).merge(Address.where.not(email: nil)).count
["jenolan@linkedin.com", "nickpurssey@yahoo.co.uk", "russelldashe@gmail.com", "xarabennettjones@gmail.com", "gavin@cleardesign.co.uk", "neil.hargrave@icloud.com", "varun.maharaj29@gmail.com", "chrisfrostt@gmail.com", "guybennettjones@hotmail.co.uk", "andy@barcadiamedia.co.uk", "adouth@hotmail.com", "anthonyjbmurphy@hotmail.com", "ray78460@gmail.com", "robinlansley@hotmail.com", "jackmertens@hotmail.co.uk", "danrichards52@gmail.com", "pinky_mctang@yahoo.co.uk", "eltringham.simon@gmail.com", "dave@gmail.com", "guybennettjones@hotmail.co.uk", "hullwj@rugbyschool.net", "jakepratley@hotmail.co.uk", "cameronwrightt@icloud.com", "matthew.wilkinson@live.co.uk", "theapreeve36@gmail.com", "davidscottpowell26@gmail.com", "roberycmay@hotmail.com", "syd.nadim@clock.co.uk"].count
exit
Cart.first
Cart.all
exit
open("http://res.cloudinary.com/dq2kcu9ey/image/upload/v1541431269/lsseq4xw3walhbzdovf3.jpg")
exit
open("")
open(nil)
exit
"john doe".titleize
exit
"john doe".titleize
"john o'brien".titleize
exit
Cart.orders.group_dy_day(:checked_out_at).count
Cart.orders.group_by_day(:checked_out_at).count
line_chart Cart.orders.group_by_day(:checked_out_at).count
exit
Cart.orders.group_by_day(:checked_out_at).count
Product.find(3).subtitle
Product.find(1).subtitle
Product.find(1)
ProductGroup.find(1).subtitle
exit
hash = {asdf: "value", key: "asdf"}
hash.keys
hash.values
exit
Address.countries.sort.map {|k,v| [v,k]}
Address.last
Address.last.class
Address.last.class.countries
Address.last.country
self = Address.last
Address
reload!
Address.test
Address.first.test
reload!
Address.first.test
reload!
Address.first.test
reload!
Address.first.test
reload!
Address.first.test
Address.last.test
Address.first.test
reload!
Address.last.test
reload!
Address.last.test
reload!
Address.last.test
reload!
Address.last.test
reload!
Address.last
Address.last.country
addr
country
nice_print
nice_print([addr,country])
country = "IR"
country = "IRE"
addr = addr + ", #{self.class.countries[self.country.to_sym]}"
addr
addr = nice_print([first_line, second_line, third_line, city, postcode])
addr = addr + ", #{self.class.countries["IRE".to_sym]}"
exit
continue
Address.last
reload!
Address.last
Address.last.update(second_line: "asdf")
Address.last
Rails.cache.clear
Address.last
exit
exit
Address.last
Rails.cache.clear
exit
addr = ""
exit
Cloudinary::Uploader.upload()
Cloudinary::Uploader.upload("logo.png")
Cloudinary::Uploader.upload("images/logo.png")
Cloudinary::Uploader.upload("app/assets/images/logo.png")
resp = Cloudinary::Uploader.upload("app/assets/images/logo.png")
resp
resp[:secure_url]
resp["secure_url"]
exit
reload!
Cart.last
Cart.last.receipt
Cart.last.receipt.url
Cart.last.receipt.remote_url
Cart.last
@cart = Cart.last
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
pdf = InvoicePdf.new(email_hash)
Cart.orders.last
@cart = Cart.orders.last
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
pdf = InvoicePdf.new(email_hash)
pdf.receipt
@cart.receipt
@cart.receipt = pdf
@cart.receipt
@cart
@cart.receipt.url
Product.first.photo
@cart.receipt.update(receipt: pdf)
@cart.update(receipt: pdf)
@cart.receipt
@cart
Product.first
Product.first.photo
@cart.receipt
pdf
@cart.update(receipt: open(pdf))
@cart.update(receipt: File.open(pdf))
@cart.update(receipt: pdf.render)
pdf.render
@cart.receipt = pdf.render
@cart.update(receipt: open(pdf.render))
@cart.update(receipt: File.open(pdf.render))
@cart
@cart.update(receipt: StringIO.new( pdf.render ) )
pdf.exists?
s = StringIO.new( pdf.render ) 
@cart.receipt = s
@cart.update(receipt: s)
s
s = StringIO.new(pdf.render)
def s.original_filename; "my file name"; end
@cart.update(receipt: s)
@cart.receipt
reload!
Cart.orders.last
Cart.orders.last.receipt
Cart.orders.last.receipt.url
Cart.orders.last.receipt.remote_url
Cart.orders.last.receipt.pasth
Cart.orders.last.receipt.path
Cart.orders.last.receipt
Cart.orders.last.receipt.file
Cart.orders.last.receipt.file.path
Cart.orders.last.receipt
Cart.orders.last.receipt.path
Cart.orders.last.receipt.receipt
exit
reload!
@cart
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
pdf
pdf.methods
pdf.bytesize
GC[:heap_live_slots]
GC.stat[:heap_live_slots]
ri dump
pdf.delete
pdf.destroy
pdf
pdf.methods
pdf.delete!
pdf.methods(false)
typeof(pdf)
pdf.class
pdf = InvoicePdf.new(email_hash).render
pdf = InvoicePdf.new(email_hash)
exit
@cart.address.email
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
continue
reload!
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
reload!
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
exit
@cart
Cart.find(632)
Cart.find(632).address
@cart = Cart.find(632)
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
reload!
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
reload!
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
GC.start
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
email_hash = { order_id: @cart.order_id, amount: @cart.amount, address: @cart.address, cart_items: @cart.cart_items, date: @cart.checkout_time }
InvoicePdf.generate(email_hash)
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
pdf = InvoicePdf.new(email_hash).render_file("RECEIPT.PDF")
PDF
pdf
receipt.pdf
PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
10.times do     pdf = InvoicePdf.new(email_hash).render_file("RECEIPT.PDF")
15.times do  PaymentMailer.success(@cart.address.email, @cart.id).deliver_later
end
exit
Address.find(441)
Address.find(442)
Address.find_by(first_name: "Guy")
@cart = Cart.find(632)
PaymentMailer.alert_mike(@cart.id).deliver_later
exit
u = User.left_outer_joins(:carts).where(carts: { user_id: nil }).where("users.updated_at <= ?", Time.now - days.days).pluck(:id)
u = User.left_outer_joins(:carts).where(carts: { user_id: nil }).where("users.updated_at <= ?", Time.now - 5.days).pluck(:id)
u = User.left_outer_joins(:carts).where(carts: { user_id: nil }).where("users.updated_at <= ?", Time.now - 5.days).pluck(:id).count
Cart.where(address_id: nil).count
Cart.left_outer_joins(:addresses).where(addresses: nil).count
Cart.left_outer_joins(:address).where(addresses: nil).count
Cart.left_outer_joins(:address).where(address: nil).count
Cart.left_outer_joins(:address).count
Cart.merge(:address).count
reload!
Cart.not_orders.count
Cart.not_orders.joins(:address).count
Cart.not_orders.first
Cart.not_orders.includes(:addresses)
Cart.not_orders.includes(:address)
Cart.not_orders.includes(:address).count
Cart.not_orders.includes(:address).where(address: !nil)
Cart.not_orders.includes(:address).where(address: nil).count
Cart.not_orders.includes(:address).where(cart: {address: nil}).count
Cart.not_orders.includes(:address).where(address: {id: nil}).count
Cart.not_orders.includes(:address).where(addresses: {id: nil}).count
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 20.days).count
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 10.days).count
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).count
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).first
Cart.find(2).user
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy
reload!
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy
exit
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy
exit
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy
reload!
exit
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy
Cart.not_orders.includes(:address).where(addresses: {id: nil}).where("carts.updated_at <= ?", Time.now - 5.days).last.destroy_all
User.first
Cart.orders.first.amount
Cart.orders.joins(:cart_items)
Cart.orders.joins(:cart_items).count
Cart.orders.joins(:cart_items).includes(:products)
Cart.orders.joins(:cart_items).includes(:products).count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(cart_items.products * cart_items.products.price))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(cart_item.products * cart_item.products.price))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(carts))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(product))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(products))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX(updated_at))
Cart.orders.joins(:cart_items).includes(:products).select("carts.*")
Cart.orders.joins(:cart_items).includes(:products).select("carts.*").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", MAX("carts.updated_at")).count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*", COUNT("carts.updated_at")).count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, COUNT(carts.updated_at")).count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, COUNT(carts.updated_at").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(carts.updated_at").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(cart_items.updated_at").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(cart_items.updated_at")).count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(cart_items.updated_at)").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(cart_items.quantity)").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, MAX(cart_items)").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, COUNT(cart_items)").count
Cart.orders.joins(:cart_items).includes(:products).select("carts.*, COUNT(cart_items.quantity)").count
exit
CartItem.joins(:carts).merge(Cart.orders)
CartItem.joins(:carts).merge(Cart.orders).count
CartItem.joins(:cart).merge(Cart.orders).count
a= CartItem.joins(:cart).merge(Cart.orders)
a.count
a.joins(:product).merge(Product.where(id: 1))
a.joins(:product).merge(Product.where(id: 1)).count
Cart.orders.count
CartItem.joins(:cart).merge(Cart.orders)
CartItem.joins(:cart).merge(Cart.orders).count
exit
ProductGroup.all
exit
Product.order
Product.order(id:)
Product.order(:id)
Product.count
Product.pluck(:id)
Product.pluck(:id).sort
(1..9).to_a
quit
172473227561451205
"172 47 3 227 56 14 51 20 5"
"172 47 3 227 56 14 51 20 5".tr(" ", "+")
exit
Cart.orders.weeks_ago(2)
0.week.ago
Date.today
Cart.orders.weeks_ago(1)
Cart.orders.weeks_ago(3)
Cart.orders.weeks_ago(3).count
reload!
Cart.orders.count
Cart.orders.launch_wk(2).count
reload!
Cart.orders.launch_wk(2).count
Cart.orders.launch_wk(5).count
reload!
Cart.orders.launch_wk(5).count
Date.parse('24 Dec 2018')
d = Date.parse('24 Dec 2018')
reload!
Cart.orders.weeks_ago(2)
Cart.orders.count
Cart.orders.weeks_ago(0)
Cart.orders.weeks_ago(1)
Cart.orders.weeks_ago(2)
Cart.orders.weeks_ago(3)
Cart.orders.weeks_ago(3).count
Cart.orders.weeks_ago(34).count
Cart.orders.weeks_ago(4).count
Cart.orders.weeks_ago(5).count
Cart.orders.weeks_ago(6).count
Cart.orders.weeks_ago(7).count
Cart.orders.weeks_ago(8).count
Cart.orders.weeks_ago(9).count
Cart.orders.weeks_ago(10).count
Cart.orders.count
reload!
Cart.orders.count
Cart.orders.weeks_ago(1)
Cart.orders.weeks_ago(2)
Cart.orders.weeks_ago(3)
reload!
Cart.orders.weeks_ago(3)
Cart.orders.weeks_ago(2)
reload!
Cart.orders.weeks_ago(2)
Cart.first
Cart.orders.where(checked_out_at: nil).count
Cart.orders.where(checked_out_at: nil)
Cart.orders.where(checked_out_at: nil).count
Cart.orders.where(checked_out_at: nil).first
Cart.orders.where(checked_out_at: nil).first.update(checked_out_at: updated_at)
Cart.orders.where(checked_out_at: nil).first.update(checked_out_at: self.updated_at)
Cart.orders.where(checked_out_at: nil).first
Cart.orders.where(checked_out_at: nil).first.update(checked_out_at: :updated_at)
Cart.orders.where(checked_out_at: nil).first
Cart.orders.where(checked_out_at: nil).first.update(checked_out_at: :updated_at)
Cart.orders.where(checked_out_at: nil).first
cart = Cart.orders.where(checked_out_at: nil).first
cart.update(checked_out_at: :updated_at)
cart
cart.checked_out_at = cart.updated_at
cart
cart.save!
cart
cart = Cart.orders.where(checked_out_at: nil).first
Cart.orders.where(checked_out_at: nil).first.update("checked_out_at = updated_at")
Cart.orders.where(checked_out_at: nil).first.update_all("checked_out_at = updated_at")
Cart.orders.where(checked_out_at: nil).where(id: 326).update_all("checked_out_at = updated_at")
Cart.find(326)
Cart.orders.where(checked_out_at: nil).count
Cart.orders.where(checked_out_at: nil).last
Cart.orders.where(checked_out_at: nil).update_all("checked_out_at = updated_at")
Cart.orders.where(checked_out_at: nil).update_all("checked_out_at = updated_at")last
Cart.orders.where(checked_out_at: nil).
Cart.orders.where(checked_out_at: nil)
Cart.find(850)
cart_item.joins(:product).merge(Product.where(id: id)).merge(Cart.weeks_ago(i)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: id)).count
id = 1
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: id)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 1)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 1,2)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: [1,2])).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).group(:product_id).merge(Product.where(id: [1,2])).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).group(:product_id)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).group(:product_id))).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).merge(Cart.weeks_ago(i)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).merge(Cart.weeks_ago(2)).count
Cart.weeks_ago(2)
Cart.orders.count
Cart.orders.weeks_ago(2)
reload!
Cart.orders.weeks_ago(2)
reload!
Cart.orders.weeks_ago(2)
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).merge(Cart.weeks_ago(2)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).merge(Cart.weeks_ago(4)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Product.where(id: 4)).merge(Cart.weeks_ago(3)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(3)).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(3)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(4)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(0)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(1)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(2)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(3)).group(:product_id).count
CartItem.joins(:cart).merge(Cart.orders).joins(:product).merge(Cart.weeks_ago(4)).group(:product_id).count
Date.parse("January")
DateTime.parse("January")
DateTime.parse("January").next_month
month = "January"
month = DateTime.parse(month)
range = month..month.next_month
Product.find(1).price
Product.all.pluck(:id, :price)
Product.all.pluck(:price)
Product.all.pluck(:id)
Product.find(1).price
Product.all.map(&:price)
Product.all.pluck(:price)
Product.all.pluck(:price_cents)
Product.all
Cart.includes(:address, cart_items: :product).orders.last(1)
Cart.joins(:address).orders.last(1)
Cart.join(:address).orders.last(1)
Cart.joins(:address, cart_items: :product).orders.last(1)
Cart.joins(:address, cart_items: :product).orders.count
Cart.includes(:address, cart_items: :product).orders.count
Cart.joins(:address, cart_items: :product).orders.uniq.count
Cart.includes(:address, cart_items: :product).orders.count
Cart.includes(:address, cart_items: :product).orders.first(2)
Cart.includes(:address, cart_items: :product).orders.first(3)
Cart.includes(:address, cart_items: :product).orders.first(1)
Cart.includes(:address, cart_items: :product).orders.first(2)
Cart.orders.includes(:address, cart_items: :product).first(2)
Cart.includes(:address, cart_items: :product).orders.last(10).reverse
Cart.includes(:address, cart_items: :product).orders.last(10).reverse.count
Cart.includes(:address, cart_items: :product).orders.last(1).reverse
Cart.includes(:address, cart_items: :product).orders.last(1).reverse.address
Cart.includes(:address, cart_items: :product).orders.last(1).reverse.address.full_name
exit
Cart.includes(:address, cart_items: :product).orders.count
Cart.joins(:address, cart_items: :product).orders.count
Cart.joins(:address, cart_items: :product).orders.uniq.count
reload!
Coupon.new
1 * 3
1.*(3)
exot
exit
nil.count
exit
Coupon.all
Coupon.find(1).carts
Coupon.find(1).carts.orders
Coupon.find(1).carts.orders.count
Coupon.find(1).amount
CartItem.all
CartItem.includes(:products)
Cart.cart_items
Cart.first.cart_items
Cart.last.cart_items
self
self.code
self.code = self.code.upcase
:check
:check.call
self.check
continue
self
up
continue
ENV[XERO_API]
ENV['XERO_API']
ENV['XERO_KEY']
client = Xeroizer::PublicApplication.new(ENV['XERO_KEY'], ENV['XERO_SECRET']
)
contacts = client.Contact.all(:order => 'Name')
client = Xeroizer::PublicApplication.new(ENV['XERO_KEY'], ENV['XERO_SECRET'])
contacts = client.Contact.all(:order => 'Name')
exit
client = Xeroizer::PublicApplication.new(ENV['XERO_KEY'], ENV['XERO_SECRET'])
contacts = client.Contact.all(:order => 'Name')
require 'rubygems'
require 'xeroizer'
client = Xeroizer::PublicApplication.new(ENV['XERO_KEY'], ENV['XERO_SECRET'])
ENV['XERO_API']
ENV['XERO_KEY']
ENV['XERO_SECRET']
client = Xeroizer::PublicApplication.new(ENV['XERO_KEY'], ENV['XERO_SECRET'])
contacts = client.Contact.all(:order => 'Name')
reload!
Coupon.where(code: "DOM")
Coupon.find(1).carts
Cart.find(1088).coupon
reload!
self
current_scope
Coupon
ids
id
cpmtomie
continue
"0".zero?
"0".to_i.zero?
"1".to_i.zero?
nil&.zero?
nil == "0"
exit
Cart.find(1090).terms
Cart.find(1090).update(terms: false)
reload!
Cart.find(1090).terms
Cart.find(1090).update(terms: false)
Cart.find(1090).terms
reload!
Cart.find(1090).terms
Cart.find(1090).update(terms: false)
reload!
Cart.find(1090).terms
reload!
Cart.find(1090).terms
reload!
exit
Money.new(2.00)
Money.new(2.00).to_f
Money.new(200).to_f
@cart.find(1080)
Cart.find(1080)
Cart.find(1080).amont
Cart.find(1080).amotnt
Cart.find(1080).amount
Cart.find(1080).amount + Money.new(200)
def amount(with_includes = true) ; with_includes ? 100 : 200 ; end
amount
amount(true)
amount(false)
def amount({with_includes = true}) ; with_includes ? 100 : 200 ; end
def amount({with_includes: true}) ; with_includes ? 100 : 200 ; end
def amount({with_includes}) ; with_includes ? 100 : 200 ; end
def amount({}) ; with_includes ? 100 : 200 ; end
def amount(h) ; h[:with_includes] ? 100 : 200 ; end
amount({})
h[asdf]
h = {}
h[asdf]
amount()
def amount(options = {}); options[:with_includes] ? 100 : 200 ' end 
def amount(options = {}); options[:with_includes] ? 100 : 200 ; end 
amount()
amount({with_includes})
amount({with_includes: true})
reload!
Cart.postage
reload!
Cart.postage
reload!
Cart.postage
exit
PaymentMailer.email_mike(@cart.id).deliver_later
Cart.last
Cart.orders.last
Address.where(first_name: "Guy")
Cart.find(632)
@cart = Cart.find(632)
PaymentMailer.email_mike(@cart.id).deliver_later
reload!
PaymentMailer.email_mike(@cart.id).deliver_later
PaymentMailer.alert_mike(@cart.id).deliver_later
exit
10.down_to 1 do |a| p a end
10.downto 1 do |a| p a end
5.times do |num|
  puts "num = #{num}"
  puts "Do you want to redo? (y/n): "
  option = gets.chop
  redo if option == 'y'
end
array.each_pair {|x,y| puts x }
array = (0..10).to_a
array.each_pair {|x,y| puts x }
array.each_slice(2) {|x,y| puts x }
array.each_slice(2) {|x,y| puts x, puts y }
array.each_slice(2) {|x,y| puts x puts y }
array.each_slice(2) {|x,y| puts x; puts y }
array.each_slice(2) {|x,y| puts "x: #{x}, y:#{y}" }
array = "tft".split("")
array.permutations
array.permutation
array = "tftf".split("")
array.permutation(2)
array.permutation {|i| puts i}
array.permutation(2) {|i| puts i}
array.permutation(2) {|i| p i}
array.permutation(3) {|i| p i}
array.permutation(2) {|i| p i}
array.permutation {|i| p i}
eval ""(t ^ (f & t))"
eval "(t ^ (f & t))"
a =  "(t ^ (f & t))"
eval "(t && (f || t))"
eval "(true && (false || true))"
array
array.gsub("t", true)
array.gsub("t", "true")
array.join("").gsub("t", "true")
array.join("").gsub("t", true)
array
array[4]
array[5]
" " + nil
s = "tft"
ops = "^&"
s.map!.with_index do |e, i|
  e = e + ops[i] if ops[i]
end
s.to_a.map!.with_index do |e, i|
  e = e + ops[i] if ops[i]
end
s.split("").map!.with_index do |e, i|
  e = e + ops[i] if ops[i]
end
s
s = s.split("").map.with_index do |e, i|
  e = e + ops[i] if ops[i]
end
s
s.compact!.join("")
s.compact!.join("")!
s.compact!.join("")
s
s = s.split("").map.with_index do |e, i|
  ops[i] ? e = e + ops[i] : e
end
s
s = "tft"
s = s.split("").map.with_index do |e, i|
  ops[i] ? e = e + ops[i] : e
end
s.join("")
array
array = s
array = s.join("").split(")
array = s.join("").split("")
array.each do {|i| i == "f" ? i = "false" : i == "t" ? i = "true" : i}
array.each {|i| i == "f" ? i = "false" : i == "t" ? i = "true" : i}
array.map {|i| i == "f" ? i = "false" : i == "t" ? i = "true" : i}
array
array.map! {|i| i == "f" ? i = "false" : i == "t" ? i = "true" : i}
true ^ false
array
array.push("&")
array.push("true")
str = array.join("")
"(true^false)&(true&true)"
"((true^false)&true)&true"
"((true^(false&true)&true"
"true^(false&true)"
"(true^false)&true)"
a = "t^f&f"
a.split("")
a.each_slice(2)
a.join("").each_slice(2)
a.split("").each_slice(2)
a.split("").each_slice(2).to_a
a.split("").each_slice(3).to_a
a.split("").reverse.each_slice(3).to_a
a.split("").reverse.each_slice(3).to_a.reverse
array
array.each_slice(3).to_a
array[1..-1].each_slice(2)
array[1..-1].each_slice(2).to_a
a = "able was i ere i saw elba".freeze
b = "able was i ere i saw elba".freeze
a.object_id
b.object_id
c = "able was i ere i saw elba"
c.object_id
d = "a"
e = "a".freeze
d.object_id
e.object_id
def print_line length
  puts '_'*length
end
10.step(50,10) do |x|
  print_line x
end
40.step(10,-10) do |x|
  print_line x
end
x = 5
def print_x
  puts x
end
x
print_x
if defined?(@@robot_count)
  @@robot_count += 1
else
  @@robot_count = 1
end
class Robot
  def initialize
    if defined?(@@robot_count)
      @@robot_count += 1
    else
      @@robot_count = 1
    end
  end
  def self.robots_created
    @@robot_count
  end
end
r1 = Robot.new
r2 = Robot.new
puts "Created #{Robot.robots_created} robots"
r3, r4, r5 = Robot.new, Robot.new, Robot.new
puts "Created #{Robot.robots_created} robots"
class A
  def public_method
    puts "Class A public method"
  end
  private
  def private_method
    puts "Class A private method"
  end
  protected
  def protected_method
    puts "Class A protected method"
  end
end
class B < A
  def get_class_a_protected_method
    protected_method # implicit call
  end
  def get_class_a_private_method
    private_method # implicit call
  end
end
class C < A
  def get_class_a_protected_method
    self.protected_method # explicit call
  end
  def get_class_a_private_method
    self.private_method # explicit call
  end
end
A.public_method
A.new.public_method
A.new.private_method
a = A.new
a
a.methods(false)
a.methods
a.singleton_methods
a.singleton_method
a.singleton_class
a.protected_method
a.protected_methods
A.new.public_method
A.new.private_method
A.new.protected_method
B.new.protected_method
C.new.protected_method
B.new.get_class_a_protected_method
C.new.get_class_a_protected_method
C.new.get_class_a_private_method
B.new.get_class_a_private_method
exit
hash = {Wed, 02 Jan 2019=>113, Thu, 03 Jan 2019=>66, Fri, 04 Jan 2019=>21, Sat, 05 Jan 2019=>14, Sun, 06 Jan 2019=>23, Mon, 07 Jan 2019=>17, Tue, 08 Jan 2019=>20, Wed, 09 Jan 2019=>16, Thu, 10 Jan 2019=>22, Fri, 11 Jan 2019=>12, Sat, 12 Jan 2019=>18, Sun, 13 Jan 2019=>21, Mon, 14 Jan 2019=>15, Tue, 15 Jan 2019=>13, Wed, 16 Jan 2019=>15, Thu, 17 Jan 2019=>36, Fri, 18 Jan 2019=>22, Sat, 19 Jan 2019=>13, Sun, 20 Jan 2019=>12, Mon, 21 Jan 2019=>22, Tue, 22 Jan 2019=>17, Wed, 23 Jan 2019=>13, Thu, 24 Jan 2019=>18, Fri, 25 Jan 2019=>12, Sat, 26 Jan 2019=>16, Sun, 27 Jan 2019=>16, Mon, 28 Jan 2019=>12, Tue, 29 Jan 2019=>9, Wed, 30 Jan 2019=>22, Thu, 31 Jan 2019=>18, Fri, 01 Feb 2019=>7, Sat, 02 Feb 2019=>8, Sun, 03 Feb 2019=>10, Mon, 04 Feb 2019=>18, Tue, 05 Feb 2019=>17, Wed, 06 Feb 2019=>19, Thu, 07 Feb 2019=>23, Fri, 08 Feb 2019=>18, Sat, 09 Feb 2019=>12, Sun, 10 Feb 2019=>16, Mon, 11 Feb 2019=>20, Tue, 12 Feb 2019=>15, Wed, 13 Feb 2019=>21, Thu, 14 Feb 2019=>11, Fri, 15 Feb 2019=>12, Sat, 16 Feb 2019=>20, Sun, 17 Feb 2019=>19, Mon, 18 Feb 2019=>16, Tue, 19 Feb 2019=>9}
Date.new("3 January 2019"))
Date.new("3 January 2019")
require 'date'
Date.new("3 January 2019")
Date.new(3, "January", "2019")
Date.new(
TimeDate.new("3 January 2019")
TimeDate.new.parse("3 January 2019")
Date.parse("3 January 2019")
exit
Persisted
exit
next
json
!!!
json
!!!
json
!!!
c
break
break --help
exit
break 4
break --help
exit
break 5
exit
!!!
context
context[:profile]
context[:profile][:first_name]
subject
subject.member_booking
subject.member_booking.first_name
!!!
subject.member_bookingA!!!
!!!
reservation
reservation.attributes
reservation.attributes.keys
reservation
!!!
context = reservation.attributes.merge!(operation_state_attribute: :create_state)
context
context = {   hotel_id: reservation.hotel_id,
  business_unit: reservation.business_unit,
  rate_plan_type: reservation.rate_plan_type,
  default_rate_plan_code: reservation.default_rate_plan_code,
  room_type_code: reservation.room_type_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: reservation.start_date,
  end_date: reservation.end_date,
  rate_plan_code: reservation.rate_plan_code,
  total: reservation.total, # TODO: don't think this is currently used
  global_id: reservation.global_id,
  guest_consent: reservation.guest_consent,
  payment_card_id: reservation.payment_card_id,
  first_name: reservation.first_name,
  last_name: reservation.last_name,
  email: reservation.email,
  phone_number: reservation.phone_number,
  address: Address.new(reservation.address),
  room_add_ons        room_add_ons        room          room_add_ons        room_add_ons        ate_attribute: :create_state
}
context = {  hotel_id: reservation.hotel_id,
  business_unit: reservation.business_unit,
  rate_plan_type: reservation.rate_plan_type,
  default_rate_plan_code: reservation.default_rate_plan_code,
  room_type_code: reservation.room_type_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: reservation.start_date,
  end_date: reservation.end_date,
  rate_plan_code: reservation.rate_plan_code,
  total: reservation.total, # TODO: don't think this is currently used
  global_id: reservation.global_id,
  guest_consent: reservation.guest_consent,
  payment_card_id: reservation.payment_card_id,
  first_name: reservation.first_name,
  last_name: reservation.last_name,
  email: reservation.email,
  phone_number: reservation.phone_number,
  address: Address.new(reservation.address),
  room_add_ons: reservation.room_add_ons,
  reservation: reservation,
  operation_state_attribute: :create_state
}
operation_state_attribute: :create_statereservation.attributes.merge!(operation_state_attribute: :create_state)
reservation.attributes.merge!(operation_state_attribute: :create_state)
reservation.attributes.merge!(operation_state_attribute: :create_state, reservation: reservation)
context = reservation.attributes.merge!(operation_state_attribute: :create_state, reservation: reservation)
context = {
  hotel_id: reservation.hotel_id,
  business_unit: reservation.business_unit,
  rate_plan_type: reservation.rate_plan_type,
  default_rate_plan_code: reservation.default_rate_plan_code,
  room_type_code: reservation.room_type_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: reservation.start_date,
  end_date: reservation.end_date,
  rate_plan_code: reservation.rate_plan_code,
  total: reservation.total, # TODO: don't think this is currently used
  global_id: reservation.global_id,
  guest_consent: reservation.guest_consent,
  payment_card_id: reservation.payment_card_id,
  first_name: reservation.first_name,
  last_name: reservation.last_name,
  email: reservation.email,
  phone_number: reservation.phone_number,
  address: Address.new(reservation.address),
  room_a        room_a        room_a        ro          room_a        room_a        room_a      ate_attribute: :create_state
}
context = {
  hotel_id: reservation.hotel_id,
  business_unit: reservation.business_unit,
  rate_plan_type: reservation.rate_plan_type,
  default_rate_plan_code: reservation.default_rate_plan_code,
  room_type_code: reservation.room_type_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: reservation.start_date,
  end_date: reservation.end_date,
  rate_plan_code: reservation.rate_plan_code, total: reservation.total, # TODO: don't think this is currently used
  global_id: reservation.global_id,
  guest_consent: reservation.guest_consent,
  payment_card_id: reservation.payment_card_id,
  first_name: reservation.first_name,
  last_name: reservation.last_name,
  email: reservation.email,
  phone_number: reservation.phone_number,
  address: Address.new(reservation.address),
  room_add_ons: reservation.room_add_ons,
  reservation: reservation,
  operation_state_attribute: :create_state
}
context
context.is_a?(Hash)
con = reservation.attributes.merge!(operation_state_attribute: :create_state, reservation: reservation)
con.is_a?(Hash)
con = reservation.attributes.merge!(operation_state_attribute: :create_state, reservation: reservation).symbolize_keys
!!!
c
n
!!!
c
n
c
!!!
n
c
!!!
c
n
!!!
n
c
!!!
n
con
context
h1 = con
h2 = context
h1.each {|k, v| result[k] = h2[k] if h2[k] != v }
result = {}
h1.each {|k, v| result[k] = h2[k] if h2[k] != v }
result
con
contesxt
context
context.except(:address)
context.except(:address) == con.except(:address)
context.to_a & con.to_a
a = context.to_a & con.to_a
a
context - a
context.to_a = a
context.to_a - a
con.to_a - a
context
con
context
a = context.to_a & con.to_a
context - a
context.to_a - a
!!!
a = context.to_a & con.to_a
context.to_a - a
con.to_a - a
context[:hotel_id]
reservation
!!!
con
a = context.to_a & con.to_a
con.to_a - a
context.to_a - a
!!!
context
reservation.attributes
!!!
reservation
n
c
reservation
context
context.reservation
require_context :reservation
required_context :reservation
context.reservation
business_unit = context.reservation.business_unit
unless validate_hotel_id(reservation.hotel_id, reservation.business_unit)
  context.fail!(:hotel_not_found, hotel_id: reservation.hotel_id)
end
unless validate_hotel_id(context.reservation.hotel_id, context.reservation.business_unit)
  context.fail!(:hotel_not_found, hotel_id: context.reservation.hotel_id)
end
context.hotel = hotel(context.reservation.hotel_id, context.reservation.business_unit)
!!!
reservation
!!!
reservation
reservation.business_unit
!!!
account
context.account
n
context.account
!!!
c
operation_state_attribute
context
context.operation_state_attribute
context.operation_state_attribute!
!!!
context
context.to_a
context.to_s
ls context
context.chidlren
context.children
context.example
context.examples
n
c
context
context.reservation
whereami
reservation.hotel_id
reservation.business_unit
n
context
whereami
resevation.rate_plan_type
reservation.rate_plan_type
reservation.rate_plan_code
n
c
n
reservation
creation.success?
creation.error
!!!
c
n
creation.error
!!!
n
c
n
context
c
n
c
n
reservation.rate_plan_type
!!!
c
reservation.rate_plan_type
reservation
delet!!!
!!!
c
!!!
reservation
reservation.first_name
c
reservation.first_name
c
reservation.first_name
c
reservation.first_name
c
reservation.first_name
context
!!!
creation.error
n
c
creation.error
c
n
step
c
build_room_booking(reservation: reservation.reload, ows_reservation: ows_reservation, hotel: hotel)
whereami
c
up
json
steo
step
@!@@
@!!
!!!
json
whereami
step
up
step
steo
step
up
json
get "/availabilities?#{params.to_query}", headers
!!!
c
json
!!!
c
n
params.dig(:filter, :start_date) < params.dig(:filter, :end_date)
params
c
n
params.dig(:filter, :start_date) < params.dig(:filter, :end_date)
n
e
n
e
n
e
n
e
n
e
c
n
@global_id
@business_unit
fetcher =  ::Services::Availabilities::Fetcher.call(
  global_id: @global_id,
  hotel_id: params.dig(:filter, :hotel_id),
  business_unit: @business_unit,
  start_date: params.dig(:filter, :start_date),
  end_date: params.dig(:filter, :end_date),
  number_of_rooms: NUMBER_OF_ROOMS,
  number_of_adults: params.dig(:filter, :number_of_adults),
  number_of_children: params.dig(:filter, :number_of_children),
  rate_plan_type: params.dig(:filter, :rate_plan_type),
  promo_rate_plan_code_group: params.dig(:filter, :promo_rate_plan_code),
  minimum_rate_cents: params.dig(:filter, :minimum_rate_cents),
  maximum_rate_cents: params.dig(:filter, :maximum_rate_cents)
)
c
n
c
n
c
context.room_type_code
n
general_availabilities
if promo_rate_plan_code_group.present?
  # Swap the rate plan code group for the matching Opera promo code
  matching_rate_plan = available_rate_plans.find { |rate_plan_code| rate_plan_code.group == promo_rate_plan_code_group }
  context.fail!(:promo_rate_plan_code_invalid, promo_rate_plan_code: promo_rate_plan_code_group) unless matching_rate_plan
  context.promo_rate_plan_code = matching_rate_plan.code
end
room_rates = ows_general_availabilities.room_types.keys.map do |room_type_code|
  room_rates_by_room = ows_general_availabilities.room_rates.select{|rr| rr.room_type_code == room_type_code }
  if promo_rate_plan_code.present?
    # if a promo_rate_plan_code is specified, filter the results to that code
    room_rates_by_room.select{|rr| rr.rate_plan_code == promo_rate_plan_code}.first
  else
    # otherwise, find the cheapest rate available for the room
    room_rates_by_room.select{|rr| available_rate_plan_codes.include?(rr.rate_plan_code) }.sort_by(&:total).first
  end
end
ows_general_availabilities.room_types
ows_general_availabilities
client.availabilities.fetch(
  {
    start_date: context.start_date,
    end_date: context.end_date,
    number_of_rooms: context.number_of_rooms || NUMBER_OF_ROOMS,
    number_of_adults: context.number_of_adults,
    number_of_children: context.number_of_children || 0
  }
)
@client ||= Services::OWSClient::Fetcher.call(hotel: hotel).ows_client
Services::OWSClient::Fetcher.call(hotel: hotel).ows_client
Services::OWSClient::Fetcher.call(hotel: hotel)
hotel
context
context.reservation
context.hotel
contedxt
context
context.hotel_id
fetcher = Hotels::Fetcher.call(hotel_id: context.hotel_id, business_unit: context.business_unit)
context
h = {hotel_id: context.hotel_id, business_unit: context.business_unit}
Hotels::Fetcher.call(h)
c
!!!
reservation
c
reservation
c
reservation
c
reservation
context
!!!
context
context.business_unit
delete :business_unit, to: :reservation
delegate :business_unit, to: :reservation
!!!
context.business_unit
context
business_unit
!!!
business_unit
context
reservation
exit
!!!
creation_error
creation.error
c
creation.error
c
creation.error
c
reservation
reservation.reload
!!!
creation
creation.error
!!!
c
creation.error
!!!
n
c
n
c
n
c
rate_plan_type
n
@@@
!!!
n
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: reservation.room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
reservation.room_type_code
reservation
!!!
reservation.room_type_code
n
!!!
n
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: reservation.room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
reservation.number_of_rooms
reservation.number_of_children
!!!
n
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: reservation.room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: reservation.number_of_rooms,
  number_of_adults: reservation.number_of_adults,
  number_of_children: reservation.number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
!!!
creation.error
!!!
n
!!!
n
# for member bookings, use a dedicated OWS profile record
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: reservation.room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: number_of_rooms,
  number_of_adults: number_of_adults,
  number_of_children: number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: number_of_rooms,
  number_of_adults: number_of_adults,
  number_of_children: number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
reservation.room_type_code
reservation.room_type_code = '1BED'
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: number_of_rooms,
  number_of_adults: number_of_adults,
  number_of_children: number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
room_type_code = '1BED'
context.ows_reservation = ows_client.reservations.create(
  profile_id: ows_profile.id,
  room_type_code: room_type_code,
  rate_plan_code: rate_plan_code,
  number_of_rooms: number_of_rooms,
  number_of_adults: number_of_adults,
  number_of_children: number_of_children,
  start_date: start_date,
  end_date: end_date,
  comments: room_add_ons
)
!!!
n
c
!!!
Reservation.new
Persisted::Reservation
Persisted::Reservation.new
Persisted::Reservation.n
!!!
c
context
context.reservation
!!!
subject
!!!
subject
subject.first_name
subject.last_name
subject.reservaiton
subject.reservation
subject.reservation.first_name
!!!
first_name
reservation
context
subject
subject.reservation
subject.reservation.first_name
subject.first_name
!!!
subject
!!!
subject
described_instance.perform(reservation.id)
!!!
!!!
body
n
original_booking
modified_booking
next
up
n
up
c
original_booking
!!!
c
body
post("/room_bookings", body, headers)
c
ecc
c
!!!
c
response.successful?
n
step
n
booking[:attributes][:state]
booking
c
prepare = Services::RoomBookings::PrepareForCreation.call(
  params.dig(:data, :relationships, :availability_rate, :data, :id).merge(
    global_id: @global_id,
    business_unit: @business_unit,
    first_name: params.dig(:data, :attributes, :first_name),
    last_name: params.dig(:data, :attributes, :last_name),
    email: params.dig(:data, :attributes, :email),
    phone_number: params.dig(:data, :attributes, :phone_number),
    address: params.dig(:data, :attributes, :address),
    room_add_ons: params.dig(:data, :attributes, :room_add_ons),
    terms_consent: params.dig(:data, :attributes, :terms_consent) == 'true',
    guest_consent: params.dig(:data, :attributes, :guest_consent),
    payment_card_id: params.dig(:data, :relationships, :payment_card, :data, :id)
  )
)
prepare.success?
c
prepare
prepare.room_booking
prepare
!!!
reservation
parent
up
c
subject
whereami
subject.first_name
subject.reservation
!!!
subject
subject.reservation
!!!
creator
creator.reservation
q
whereami
c
subject.reservation
subject.last_name
!!!
reservation
first_name
last_name
reservation.first_name
!!!
creator.reservation
c
modify_parameters
described_class.call(
  id: reservation_id,
  global_id: global_id,
  business_unit: business_unit,
** modify_parameters)
mod =described_class.call(
  id: reservation_id,
  global_id: global_id,
  business_unit: business_unit,
** modify_parameters)
mod = described_class.call(
  id: reservation_id,
  global_id: global_id,
  business_unit: business_unit,
** modify_parameters)
!!!
creator.reservaiton
creator.reservation
c
modify_parameters
mod = described_class.call(
  id: reservation_id,
  global_id: global_id,
  business_unit: business_unit,
** modify_parameters)
mod.reservation
mod.reservation.email
modify_parameters
!!!
c
email_changed?
email
ows_profile.email
name_changed.
c
name_changed?
c
creator.reservation.first_name
creator.first_name
c
modify_parameters
c
context.reservation.first_name
context.first_name
!!!
email_changed?
context.reservation
whereami
name_changeX?
name_changed?
context.reservation
reservation
whereami
ows_profile
c
creator.success?
c
modify_parameters
c
email_changed?
first_name
context.first_name
context.reservation.first_name
c
new_profile_required
ows_reservation_modified
c
!!!
new_profile_required
availability_rate_changed || new_profile_required || ows_reservation_modified
!!!
name_changed?
context.reservation
context.first_name
context.reservation.first_name
exit
!!!
Fir
Dir
Dir.pwd
Dir.mkdir
Dir.mkdir rubyy
Dir.mkdir "rubyy"
Dir.exist? "rubyy"
Dir.rmdir "rubyy"
File.new "rubyy"
File
File.new
File.new -h
File.new()
File.attributes
!!!
Digest
require 'digest'
Digest
Digest::SHA
Digest::Sha
Digest::MD5
Digest::SHA1
Digest::SHA1.hexdigest 'adsf'
Digest::SHA1.file 'asdf'
exit
ENV['RACK_ENV']
ENV['RACK_ENV'].to_sym
n
c
!!!
CSV.read('perks.csv')
require 'csv'
csv = 
CSV.read('perks.csv')
CSV.read('perks.csv', headers: true)
csv = CSV.read('perks.csv', headers: true)
csv[0]
csv[1]
csv[2]
csv[3]
csv.each {|row| puts row[0]}
csv.each {|row| puts row["Date added"]}
csv = CSV.read('perks.csv', headers: true)
csv[0]
csv = CSV.read('perks.csv', headers: true)[3..-1
csv = CSV.read('perks.csv', headers: true)[3..-1]
"About Greek Sandals".parameterize
"About Greek Sandals".underscore
row
csv[4]
csv[4][1]
csv[4]
csv[4].to_yaml
csv[4].to_hash
csv.headers
csv
csv = CSV.read('perks.csv', headers: true)[3..-1]
csv
csv = CSV.read('perks.csv', headers: true)
csv.headers
csv.headers.map(:downcase)
csv.headers.map(&:downcase)
csv.headers.map{|i| i.downcase.tr(' ', '_') if i}
row['short_description']
row[3]['short_description']
csv[3]['short_description']
csv[4]['short_description']
csv[4]
csv.headers.map!{|i| i.downcase.tr(' ', '_') if i}
csv[4]
csv[4]['Short Description']
csv.headers
csv
csv = csv.headers.map{|header| uniform_names(header) }
def uniform_names(name)
  name.downcase.tr(' ', '_') if name
end
csv = csv.headers.map{|header| uniform_names(header) }
csv
CSV::HeaderConverters[:map_to_main] = lambda do |header|
  uniform_names(header)
end
file = 'perks.csv'
CSV.open(file,
  headers: true,
header_converters: :map_to_main))
header_converters: :map_to_main)
CSV.open(file, headers: true, header_converters: :map_to_main)
csvCSV.open(file, headers: true, header_converters: :map_to_main)
csv = CSV.open(file, headers: true, header_converters: :map_to_main)
csv.first
CSV::HeaderConverters[:map_to_main] = lambda do |header|
  uniform_names(header)
end
CSV.read(file, headers: true, header_converters: :map_to_main)
c = CSV.read(file, headers: true, header_converters: :map_to_main)
csv = CSV.read(file, headers: true, header_converters: :map_to_main)
csv
csv[0]
csv.select{|row| row["Date Added"].exists? }
csv
csv.first
csv.select{|row| row["date_added"].exists? }
csv.select{|row| row["date_added"].present? }
nil.empty?
nil.blank?
nil.present?
nil.nil?
nil.methods
csv.select{|row| row["date_added"].present? }
csv
csv.select{|row| row["date_added"] }
csv
csv.drop(10
csv.drop(1)
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv[0]
csv[1]
csv[2]
csv.drop(3)
csv
csv.methods(false)
csv.methods
csv
csv.drop!(3)
csv = csv.drop(3)
csv
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv.drop(1)
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv[0]
csv[1]
csv[2]
csv = csv.drop(3).reject{|row| row["Date Added"].nil? }
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv = csv.drop(3)
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv = csv.drop(3).reject{|row| row["date_added"].nil? }
csv
Dir.mkdir('hey')
exit
n
dir_name
Dir.mkdir(dir_name)
Dir.chdir(dir_name)
Dir.pwd
File.open('data.yml','w') do |f|
  f.write row_to_yaml_hash(row)
end
row
yaml_hash = row.to_hash.slice("title",
  "region",
  "created_at",
  "promotion_code",
  "url",
  "header_image_alt_text",
  "body_title",
  "body_image_alt_text",
"body_image_caption")
date_arr = yaml_hash['created_at'].split('/')
row.to_HASH
row.to_hash
!!!
111
!!!
"asdf".starts_with?('a')
"asdf".start_with?('a')
exiut
exit
yaml_hash
yaml_hash.ex
!!!
row.slice("title")
!!!
yaml_hash
!!!
c
yaml_hash
n
yaml_hash
n
date_arr
n
yaml_hash
!!!
c
yaml_hash
!!!
yaml_hash['date_added']
Date.parse(yaml_hash['date_added'])
Date.parse(yaml_hash['date_added']).strftime("%Y-%m-%d")
Date.parse(yaml_hash['date_added'], "%d/%m/%y").strftime("%Y-%m-%d")
Date._strptime(yaml_hash['date_added'], "%d/%m/%y").strftime("%Y-%m-%d")
Date.strptime(yaml_hash['date_added'], "%d/%m/%y").strftime("%Y-%m-%d")
date = Date.strptime(yaml_hash['date_added'], "%d/%m/%y").strftime("%Y-%m-%d"))
date = Date.strptime(yaml_hash['date_added'], "%d/%m/%y").strftime("%Y-%m-%d")
!!!
d = Date.strptime(yaml['date_added'], "%d/%m/%y")
d = Date.strptime(yaml['date_added'], "%d/%m/%y").strftime("%Y-%m-%d")
yaml['created_at'] = d
yaml
yaml.delete('date_added')
yaml
!!!
c
yaml_hash
c
yaml_hash
yaml_hash.map { |k,v| "#{k}: \"#{row[k]}\"\n" }.join('')
yaml_hash.map { |k,v| "#{k}: \"#{row[k]}\"\n" }
yaml_hash.keys
string = ""
yaml_hash['created_at']
yaml_hash['created_at'].to_s
yaml_hash['created_at'].class
!!!
row[4]
csv[4]
csv.headers
csv[4].headers
csv[4]['image_body_url']
csv[5]['image_body_url']
csv[6]['image_body_url']
csv
csv[1]['image_body_url']
url = csv[1]['image_body_url']
Dir.chdir('data/perks')
Rails.root
root
exit
echo $WORKING_DIR
WORKING_DIR
APP_ROOT
exit
APP_ROOT
Pathname.new File.expand_path('../..', __FILE__)
EXIT
!!!
APP_ROOT = Pathname.new File.expand_path('./', __FILE__)
APP_ROOT = Pathname.new File.expand_path('../', __FILE__)
!!!
APP_ROOT
n
c
n
next
Dir.pwd
!!!
dir_name
!!!
dir_name
!!!
wherami
row
row['body_image_url']
!!!
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
csv.by_col!
csv.by_col!.delete_if {|n,v| n.nil?}
csv[0]
!!!
args
args.first
!!!
args.first
args
environment
:environment
_task
args[:environment]
!!!
args[:file]
env
ENV
ENV.values
!!!
args
args.to_s
args.methods
args.to_a
_task
!!!
args.display_times
args
!!!
ARGV
ARGV.count
ARGV[1]
ARGV[2]
filename = ARGV[1] ? ARGV[1] : 'perks.csv'
filename = ARGV[1] ? ARGV[1] : 'perks.csv    filename = ARGV[1] || 'perks.csv''
filename = ARGV[1] || 'perks.csv'
filename = ARGV[2] || 'perks.csv'
filename = ARGV[1] || 'perks.csv'
!!!
args
args.first
argsargs
asrgs
args
args[:file]
args[:file].class
CSV.read(args.[:file])
CSV.read(args[:file])
!!!
CSV.read(args[:file])
Dir.pwd
Dir.ls
ls
CSV.read('perks.csv')
CSV.read(args[:file])
args[:file]
!!!
args[:file]
!!!
n
APP_ROOT
APP_ROOT = Pathname.new File.expand_path('../..', __FILE__)
!!!
APP_ROOT
n
APP_ROOT
n
Dir.pwd
!!!
n
APP_ROOT
!!!
n
dir_name
c
dir_name
convert_names(row['body_title'])
c
convert_names(row['body_title'])
c
convert_names(row['body_title'])
c
convert_names(row['body_title'])
c
convert_names(row['body_title'])
c
convert_names(row['body_title'])
row
!!!
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
convert_to_html(row['short_description'])
c
desc = convert_to_html(row['terms_and_conditions'])
c
desc = convert_to_html(row['terms_and_conditions'])
c
desc = convert_to_html(row['terms_and_conditions'])
c
desc = convert_to_html(row['terms_and_conditions'])
row['terms_and_conditions']
!!!
"hey   ".strip
!!!
desc
desc.split("\n")
!!!
desc
c
desc
c
desc
c
desc
c
desc
c
desc
c
desc
c
desc
desc.split('\n')
desc.split("\n")
desc.split("\n").reject(&:blank?)
!!!
mandatory.first
row
row[mandatory.first]
row['region']
mandatory.none? {|k| row[k] || row[k].blank? }
raise MandatoryError if mandatory.none? {|k| row[k] || row[k].blank? }
c
!!!
raise MandatoryError if mandatory.none? {|k| row[k] || row[k].blank? }
throw MandatoryError if mandatory.none? {|k| row[k] || row[k].blank? }
throw MandatoryError
raise MandatoryError
raise 
c
mandatory.none? {|k| row[k] || row[k].blank? }
row
!!!
'asdf'.append('asdf'0
'asdf'.append('asdf')
exit
hist
Pry
Readline::HISTORY
Readline::HISTORY.first
Readline::HISTORY.last
Readline::HISTORY.count
Readline::HISTORY.each {|i| p i if i.includes?("csv")
}
Readline::HISTORY.each {|i| p i if i.include?("csv")}
csv = CSV.read('perks.csv', headers: true, header_converters: :map_to_main)
require 'csv'
Readline::HISTORY.each {|i| p i if i.include?("map")}
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
filename = args[:filename] || 'perks.csv'
filename = 'perks.csv'
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
def convert_names(name)
  name&.downcase&.tr(' ', '_')
end
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
csv.map(&:image_header_url)
csv.map{|row| row[:image_header_url])
csv.map{|row| row[:image_header_url]})
csv.map{|row| row[:image_header_url]}
csv.map{|row| row["image_header_url"]}
exit
def convert_names(name)
  name&.downcase&.tr(' ', '_')
end
def row_to_yaml(row)
        yaml_hash = row.to_hash
                       .slice('title',
                                'region',
                            'date_added',
                            'promotion_code',
                            'url',
                            'header_image_alt_text',
                            'body_title',
                            'body_image_alt_text',
                            'body_image_caption')
                     .reject { |_, v| v.nil? || v.empty? }
      if yaml_hash[‘region’] == ’NORTH AMERICA’
        yaml_hash[‘region’] = NORTH_AMERICA
      end
      convert_date(yaml_hash)
      yaml_hash.map { |k, v| "#{k}: \"#{v.strip}\"\n" }
               .join('')
    end
!!!
exit
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
def convert_names(name)
  name&.downcase&.tr(' ', '_')
end
require 'csv'
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
filename = 'perks.csv'
csv = CSV.read(filename, headers: true, header_converters: ->(header) { convert_names(header) })
csv = csv.drop(3).reject { |row| row['date_added'].nil? }
row.to_hash
.slice('title',
'region',
'date_added',
'promotion_code',
'url',
'header_image_alt_text',
'body_title',
'body_image_alt_text',
'body_image_caption')
csv.first
csv.first.headers
exit
require 'virtus'
require 'common_api'
exiy
exit
require 'common_api'
class Dog ; include Virtus.model ; attribute :expires_on, Date ; end
Dog.new
Dog.new(expires_on: 'asd')
Dog.new(expires_on: 'June 30th, 2019')
Perka.ll
Perk.all
Perk.new
Perk.new(promotion_code: "asdf")
ALL_PERKS
Perks.constants
Perk.constants
Perk::ALL_PERKS
exit
exit
Date.today + 28.days
require 'date'
Date.today + 28.days
require 'activesupport'
require 'active_support'
Date.today + 28.days
28.days
require 'active_support'
28.days
require 'active_support/time'
28.days
Date.today + 28.days
Date.today + 29.days
Date.parse(" Mon, 08 Jul 2019"0
Date.parse(" Mon, 08 Jul 2019")
str = "asdf & asdf"
str.gsub(/&/, 'and')
str.gsub("&", 'and')
str.tr("&", 'and')
str = "asdf .: asdf"
str.gsub(/\./, "dot")
str.tr(".", "dot")
exit
[[:punct:]]
[[:punct]]
str = "buy_a_10_times_clip_card_(for_10_classes)_and_get_"
str.gsub([[:punct]], ".")
str.gsub("[[:punct]]", ".")
str
str.gsub("[[:punct]]", "")
[[:punct:]].join('')
[[:punct]].join('')
str.gsub(/[^a-z0-9\s]/i, '')
str.gsub(/[^a-z0-9\s_]/i, '')
exit
row
row.headers
row[image_header_url]
row['image_header_url']
c
row['title']
row['image_header_url']
row
exit
!!!
require 'mechanize'
exit
require 'mechanize'
agent = Mechanize.new  
page = agent.get "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view?usp=sharing"
form = page.forms.first  
page.forms
page
page.links
page.links.first
page.links.first.click
sign_in = page.links.first.click
sign_in.forms
sign_in.forms.first
sign_in.forms.first.email
sign_in.forms.first.Email
sign_in.forms.first.Email = "guybjoness@gmail.com"
sign_in.forms.first.PasswordSeperationSignIn
sign_in.forms.first.password
sign_in.forms.first.Password
sign_in.forms.first.Page
page = agent.get "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view"
require 'nokogiri'
Nokogiri::HTML(open('require 'gdata/client'  
require 'gdata/http'  
require 'gdata/auth'  
client = GData::Client::Spreadsheets.new  
Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view').read)
Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view'))
url = "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view"
open(url)
require 'open-uri'
open(url)
Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view'))
html = Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view'))
html = Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view').read)
html = Nokogiri::HTML(open('https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view'))
html
html.xpath(//img)
html.xpath("//img")
html.FindElements
html.xpath("*img")
html.xpath("//*img")
exit
require 'google_drive'
exit
require 'watir'
browser = Watir::Browser.new
exit
require 'watir'
browser = Watir::Browser.new
require 'watir'
url = "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view"
browser = Watir::Browser.new
browser.goto url
browser.wait(5)
i = browser.div alt: "Displaying CWH Perk_Brash Coffee.jpeg"
i.exist?
i = browser.div alt: "Displaying CWH Perk_Brash Coffee.jpeg"
hash = {a:123}
hash[:a] = hash[:b]
hash
hash = {a:123}
hash[:b] = hash.delete(:a)
hash
exit
row.headers
exit
n
yaml_hash
!!!
i
i = browser.div class: "ndfHFb-c4YZDc-HiaYvf-RJLb9c"
browser
exit
require 'watir'
url = "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view"
b = Watir::Browser.start url
i = browser.div alt: "Displaying CWH Perk_Brash Coffee.jpeg"
i = b.div alt: "Displaying CWH Perk_Brash Coffee.jpeg"
i = b.img alt: "Displaying CWH Perk_Brash Coffee.jpeg"
i = b.img
require 'watir'
exit
require 'watir'
url = "https://drive.google.com/file/d/1xNt4CpYJdZOlt61-Aryr5hSE-y5HInR2/view"
b = Watir::Browser.start url
b.img(alt: /Displayin/)
b.img(alt: /Displaying/)
b.img(class: "nd")
b.element(tag_name: 'img')(
b.element(tag_name: 'img')
b
b.div
b.element(tag_name: 'img')
b.element(tag_name: /img/)
b.element(tag_name: 'div')
b.div(class: /ndfHFb-c4YZDc ndfHFb-c4YZDc-AHmuwe-Hr88gd-OWB6Me ndfHFb-c4YZDc-vyDMJf-aZ2wEe ndfHFb-c4YZDc-i5oIFb ndfHFb-c4YZDc-TSZdd/)
exit
c
data = 
data
perk_id
exit
!!!
hash = {perks_url: "google.com", image_header_alt_text: 'asdf', image_body_alt_text: 'body'}
data = {perks_url: "google.com", image_header_alt_text: 'asdf', image_body_alt_text: 'body'}
def map_keys(data, key_map)
  key_map.each do |old, new|
    data[old] = data.delete(new)
  end
  return data
end
data = {'perks_url' => "google.com", 'image_header_alt_text' => 'asdf', 'image_body_alt_text' => 'body'}
n = map_keys(data, {'perks_url => 'url'})
n = map_keys(data, {'perks_url' => 'url'})
data
map_keys
map_keys(1,2)
map_keys(data,2)
map_keys(data,{'perks_url' => 'url'})
data = {'perks_url' => "google.com", 'image_header_alt_text' => 'asdf', 'image_body_alt_text' => 'body'}
map_keys(data,{'perks_url' => 'url'})
data = {'perks_url' => "google.com", 'image_header_alt_text' => 'asdf', 'image_body_alt_text' => 'body'}
data['perks_url']
exit
"asdf".first(30)
exit
require 'open-uri'
open("https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view?usp=sharing")
open("https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view?usp=sharing").read
r = open("https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view?usp=sharing")
r.response
r.headers
exit
require 'google/apis/drive_v2'
Drive = Google::Apis::DriveV2 # Alias the module
drive = Drive::DriveService.new
equire 'google/api_client'
require 'google/api_client/auth/file_storage'
require 'google/api_client/auth/installed_app'
class GoogleDrive
  CREDENTIALS_FILE = Rails.root.join('tmp', 'google_api_credentials.json')
  def initialize
    credentials_storage = ::Google::APIClient::FileStorage.new(CREDENTIALS_FILE)
    @client = ::Google::APIClient.new(
      application_name:    'MyApp',
      application_version: '1.0.0'
    )
    @client.authorization = credentials_storage.authorization || begin
      installed_app_flow = ::Google::APIClient::InstalledAppFlow.new(
        client_id:     ENV['GOOGLE_API_CLIENT_ID'],
        client_secret: ENV['GOOGLE_API_CLIENT_SECRET'],
        scope:         ENV['GOOGLE_API_SCOPE']
      )
      installed_app_flow.authorize(credentials_storage)
    end
    @drive = @client.discovered_api('drive', 'v2')
  end
  def download_latest_proxylist(search_period = 1.week.ago)
    modified_date = search_period.strftime('%Y-%m-%dT%H:%M:%S%z')
    result = @client.execute(
      api_method: @drive.files.list,
      "                                             e}"                    file = result.data['items'].first
      download_url = file['downloadUrl']
      result = @clie    result = @clie    result = @clie    result = @clie    result = @clie    resig    result = @clie    result = @clie t_    result = @clie    result = @cldDate']
  end
end
require 'google/api_client'
require 'google/api_client/auth/file_storage'
require 'google/api_client/auth/installed_app'
require 'google/api_client'
require 'google/api_client/auth/file_storage'
require 'google/api_client/auth/installed_app'
exit 
require 'google/api_client'
require 'google/api_client/auth/file_storage'
require 'google/api_client/auth/installed_app'
require 'signet/oauth_2/client'
exit
require 'google/apis/drive_v3'
require 'googleauth'
require 'googleauth/stores/file_token_store'
require 'fileutils'
OOB_URI = 'urn:ietf:wg:oauth:2.0:oob'.freeze
APPLICATION_NAME = 'Drive API Ruby Quickstart'.freeze
CREDENTIALS_PATH = 'credentials.json'.freeze
# The file token.yaml stores the user's access and refresh tokens, and is
# created automatically when the authorization flow completes for the first
# time.
TOKEN_PATH = 'token.yaml'.freeze
SCOPE = Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY
def authorize
  client_id = Google::Auth::ClientId.from_file(CREDENTIALS_PATH)
  token_store = Google::Auth::Stores::FileTokenStore.new(file: TOKEN_PATH)
  authorizer = Google::Auth::UserAuthorizer.new(client_id, SCOPE, token_store)
  user_id = 'default'
  credentials = authorizer.get_credentials(user_id)
  if credentials.nil?
    url = authorizer.get_authorization_url(base_url: OOB_URI)
    puts 'Open the following URL in the browser and enter the ' \
    "resulting code after authorization:\n" + url
    code = gets
    credentials = authorizer.get_and_store_credentials_from_code(
      user_id: user_id, code: code, base_url: OOB_URI
    )
  end
  credentials
end
drive_service = Google::Apis::DriveV3::DriveService.new
drive_service.client_options.application_name = APPLICATION_NAME
drive_service.authorization = authorize
response = drive_service.list_files(page_size: 10,
fields: 'nextPageToken, files(id, name)')
puts 'Files:'
puts 'No files found' if response.files.empty?
response.files.each do |file|
  puts "#{file.name} (#{file.id})"
end
file_id = 1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU
file_id = "1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU"
content = drive_service.get_file(file_id, download_dest: StringIO.new)
content = drive_service.export_file(file_id,
  'application/pdf',
download_dest: StringIO.new)
content = drive_service.export_file(file_id, 'image/jpeg', download_dest: StringIO.new)
doc = system('wget "https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view" | grep usercontent')
doc
doc = system('wget "https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view"')
doc
exit
require 'nokogiri'
require 'open-uri'
url = "https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view"
open(url)
open(url).read
open(url).read.grep /user/
"asdf".match(/a/)
open(url).read.match /user/
"asdf".match(/a/)[0]
open(url).read.match(/http.*usercontent/)
open(url).read.match(/content=\"http.*usercontent/)
open(url).read.match(/content=\"http.*usercontent\"/)
open(url).read.match(/content=\"http.*usercontent.*\"/)
open(url).read.match(/content=\"http.*usercontent.*>/)
open(url).read.match(/content=\"http.*usercontent.com\/.*/)
open(url).read.match(/content=\"http.*usercontent.com\/.*/)[0]
open(url).read.match(/content=\"http.*usercontent/)
open(url).read.match(/content=\"http.*usercontent.com/)
exit
open(url).read.match(/content=\"http.*usercontent.com.*\"></)
open(url).read.match(/content=\"http.*usercontent.com.*\"><meta/)
exut
url = "https://drive.google.com/file/d/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU/view"
file_id = url.match(/\/d\/(.*)//)
file_id = url.match(/\/d\/(.*)\//)
file_id = url.match(/\/d\/(.*)\//)[1]
exit
require 'open-uri'
url = "https://doc-10-b4-docs.googleusercontent.com/docs/securesc/1kmev7k9fr65f9as8ar955k444e8tun8/2d686t7nrktof9kh7cjitemor2boajb2/1560866400000/12078492223780681176/18065501857109472115/1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU?e=view"
u = open(url)
r = u.read
url = "https://drive.google.com/uc?id=1KXD6dE1Cl7PhWWWiiK7zvKcqIOHrvCLU&export=download"
open(url_
open(url)
open(url).read
File.open('body_image.jpg', 'wb') do |f|
  f.write Security.open(row['body_image_url']).read
end
File.open('body_image.jpg', 'wb') do |f|
  f.write open(row['body_image_url']).read
end
url
File.open('body_image.jpg', 'wb') do |f|
  f.write open(url).read
end
hash = {'key' => 'value', 'key2' => 'value2'}
hash['key3'] = hash.delete('key')
hash
hash['key'] = hash.delete('key3')
hash
def rename_keys(hash, key_hash)
  key_hash.each {|k,v| hash[k] = hash.delete(v)}
end
rename_keys(hash, {'key' => 'another_key'})
def rename_keys(hash, key_hash)
  key_hash.map {|k,v| hash[k] = hash.delete(v)}
end
rename_keys(hash, {'key' => 'another_key'})
key_hash.values.first
key_hash = {'key' => 'another_key'}
key_hash.values.first
def rename_keys(hash, key_hash)
  key_hash.each {|k,v| hash[k] = hash.delete(v)}
  return hash
end
hash
hash = {'key' => 'value', 'key2' => 'value2'}
rename_keys(hash, {'key' => 'another_key'})
exit
hash = {'key' => 'value', 'key2' => 'value2'}
def rename_keys(hash, key_hash)
  key_hash.each { |k,v| hash[v] = hash.delete(k) }
  return key_hash
end
rename_keys(hash, {'key' => 'another_key'})
def rename_keys(hash, key_hash)
  key_hash.each { |k,v| hash[v] = hash.delete(k) }
  return hash
end
rename_keys(hash, {'key' => 'another_key'})
hash = {'key' => 'value', 'key2' => 'value2'}
rename_keys(hash, {'key' => 'another_key'})
hash
hash = {'key' => 'value', 'key2' => 'value2'}
key_hash = { 'key' => 'another_keu'}
hash
hash.map{|k,v| [key_hash[k], v].to_h }
hash.map{|k,v| [key_hash[k] || k, v].to_h }
hash.map{|k,v| [key_hash[k] || k, v]}.to_h 
exit
def convert_to_html(desc)
  return if desc.start_with?('<p>')
  desc.split("\n").reject(&:blank?).map { |para| "<p>#{para}</p>" }.join("\n")
end
desc = "hey"
convert_to_html(desc)
desc = "hey\n"
convert_to_html(desc)
'hey".split("\n")
"hey".split("\n")
"hey".split("\n").reject(&:blank?)
"hey".blank?
require 'active_support/core_ext'
require 'active_support'
require 'active_support/core_ext'
"hey".blank?
convert_to_html(desc)
desc
a = convert_to_html(desc)
convert_to_html(a)
a
def convert_to_html(desc)
  return desc if desc.start_with?('<p>')
  puts 'asdf'
end
convert_to_html(a)
require 'datetime'
DateTime.parse("December 2019")
require 'date'
DateTime.parse("December 2019")
require 'rails'
{'low' => 2}
{:low => 2}
{low: 2}
10 / 3
exit
